/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/alternateDimension.ts":
/*!***********************************!*\
  !*** ./src/alternateDimension.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AlternateDimension = exports.DimensionType = void 0;\nvar enemy_1 = __webpack_require__(/*! ./enemy */ \"./src/enemy.ts\");\nvar cloudMob_1 = __webpack_require__(/*! ./cloudMob */ \"./src/cloudMob.ts\");\nvar bumbleBee_1 = __webpack_require__(/*! ./bumbleBee */ \"./src/bumbleBee.ts\");\nvar DimensionType;\n(function (DimensionType) {\n    DimensionType[DimensionType[\"Dark\"] = 0] = \"Dark\";\n    DimensionType[DimensionType[\"Grass\"] = 1] = \"Grass\";\n})(DimensionType || (exports.DimensionType = DimensionType = {}));\nvar AlternateDimension = /** @class */ (function () {\n    function AlternateDimension(width, height, context, dimensionType, player, terrain, game) {\n        if (dimensionType === void 0) { dimensionType = DimensionType.Dark; }\n        this.dotRadius = 25;\n        this.portalRadius = 25;\n        this.islands = [];\n        this.bridges = [];\n        this.bumbleBees = [];\n        this.width = width;\n        this.height = height;\n        this.context = context;\n        this.dimensionType = dimensionType;\n        this.player = player;\n        this.terrain = terrain;\n        this.game = game;\n        if (this.dimensionType === DimensionType.Dark) {\n            this.walls = this.createFixedMap();\n        }\n        else {\n            this.walls = []; // No walls in grass dimension\n            this.islands = this.generatePermanentIslands();\n            this.bridges = this.generateBridges();\n            this.generateBumbleBees();\n        }\n        this.regularPortalLocation = this.findSafePortalLocation();\n        this.grassPortalLocation = this.findSafePortalLocation();\n        this.dots = this.generateDots();\n        this.grassPatches = this.generateGrassPatches();\n    }\n    AlternateDimension.prototype.generatePermanentIslands = function () {\n        return [\n            { x: 1000, y: 1000, radius: 500 },\n            { x: 3000, y: 1500, radius: 600 },\n            { x: 5000, y: 1000, radius: 550 },\n            { x: 7000, y: 1500, radius: 450 },\n            { x: 1500, y: 3000, radius: 400 },\n            { x: 4000, y: 3500, radius: 700 },\n            { x: 6500, y: 3000, radius: 500 },\n            { x: 2000, y: 5000, radius: 550 },\n            { x: 5000, y: 5500, radius: 600 },\n            { x: 8000, y: 5000, radius: 450 },\n            { x: 1000, y: 7000, radius: 500 },\n            { x: 3500, y: 7500, radius: 650 },\n            { x: 6000, y: 7000, radius: 550 },\n            { x: 8000, y: 7500, radius: 400 },\n        ];\n    };\n    AlternateDimension.prototype.generateBridges = function () {\n        return [\n            { start: { x: 1500, y: 1000 }, end: { x: 2400, y: 1500 }, width: 200 },\n            { start: { x: 3600, y: 1500 }, end: { x: 4450, y: 1000 }, width: 200 },\n            { start: { x: 5550, y: 1000 }, end: { x: 6550, y: 1500 }, width: 200 },\n            { start: { x: 1500, y: 1500 }, end: { x: 1500, y: 2600 }, width: 200 },\n            { start: { x: 3000, y: 2100 }, end: { x: 3300, y: 3500 }, width: 200 },\n            { start: { x: 4700, y: 3500 }, end: { x: 6000, y: 3000 }, width: 200 },\n            { start: { x: 7000, y: 1950 }, end: { x: 7000, y: 2500 }, width: 200 },\n            { start: { x: 1900, y: 3000 }, end: { x: 2000, y: 4450 }, width: 200 },\n            { start: { x: 4000, y: 4200 }, end: { x: 4400, y: 5500 }, width: 200 },\n            { start: { x: 5600, y: 5500 }, end: { x: 7550, y: 5000 }, width: 200 },\n            { start: { x: 2550, y: 5000 }, end: { x: 3500, y: 6850 }, width: 200 },\n            { start: { x: 5000, y: 6100 }, end: { x: 5450, y: 7000 }, width: 200 },\n            { start: { x: 6550, y: 7000 }, end: { x: 7600, y: 7500 }, width: 200 },\n        ];\n    };\n    AlternateDimension.prototype.isOnIslandOrBridge = function (x, y) {\n        return this.isInsideIsland(x, y) || this.isOnBridge(x, y);\n    };\n    AlternateDimension.prototype.isInsideIsland = function (x, y) {\n        return this.islands.some(function (island) {\n            var distance = Math.sqrt(Math.pow(x - island.x, 2) + Math.pow(y - island.y, 2));\n            return distance < island.radius + 5; // Add a 5-pixel buffer\n        });\n    };\n    AlternateDimension.prototype.isOnBridge = function (x, y) {\n        return this.bridges.some(function (bridge) {\n            var A = { x: bridge.start.x, y: bridge.start.y };\n            var B = { x: bridge.end.x, y: bridge.end.y };\n            var C = { x: x, y: y };\n            var distAB = Math.sqrt(Math.pow(B.x - A.x, 2) + Math.pow(B.y - A.y, 2));\n            var distAC = Math.sqrt(Math.pow(C.x - A.x, 2) + Math.pow(C.y - A.y, 2));\n            var distCB = Math.sqrt(Math.pow(B.x - C.x, 2) + Math.pow(C.y - B.y, 2));\n            // Increase the effective width of the bridge hitbox\n            var effectiveWidth = bridge.width * 1.5; // 50% wider hitbox\n            var halfWidth = effectiveWidth / 2;\n            // Check if the point is within the bounding box of the bridge\n            var minX = Math.min(A.x, B.x) - halfWidth;\n            var maxX = Math.max(A.x, B.x) + halfWidth;\n            var minY = Math.min(A.y, B.y) - halfWidth;\n            var maxY = Math.max(A.y, B.y) + halfWidth;\n            if (C.x < minX || C.x > maxX || C.y < minY || C.y > maxY) {\n                return false;\n            }\n            // Check if the point is close enough to the bridge line\n            var crossProduct = Math.abs((C.y - A.y) * (B.x - A.x) - (C.x - A.x) * (B.y - A.y));\n            var distanceFromLine = crossProduct / distAB;\n            return distanceFromLine <= halfWidth && (distAC + distCB <= distAB + effectiveWidth / 2);\n        });\n    };\n    AlternateDimension.prototype.generateGrassPatches = function () {\n        var patches = [];\n        var patchCount = 50;\n        for (var i = 0; i < patchCount; i++) {\n            patches.push({\n                x: Math.random() * this.width,\n                y: Math.random() * this.height,\n                radius: Math.random() * 100 + 50\n            });\n        }\n        return patches;\n    };\n    AlternateDimension.prototype.generateDots = function () {\n        var dots = [];\n        var dotCount = 1000;\n        var attempts = 0;\n        var maxAttempts = 10000;\n        while (dots.length < dotCount && attempts < maxAttempts) {\n            var x = Math.random() * this.width;\n            var y = Math.random() * this.height;\n            var isValidLocation = this.dimensionType === DimensionType.Dark\n                ? !this.isInsideWall(x, y)\n                : this.isOnIslandOrBridge(x, y);\n            if (isValidLocation && !this.isOverlappingDots(x, y, dots) && !this.isOverlappingPortal(x, y)) {\n                dots.push({\n                    x: x,\n                    y: y,\n                    present: true\n                });\n            }\n            attempts++;\n        }\n        return dots;\n    };\n    AlternateDimension.prototype.isInsideWall = function (x, y) {\n        var _this = this;\n        return this.walls.some(function (wall) {\n            return x - _this.dotRadius < wall.x + wall.width &&\n                x + _this.dotRadius > wall.x &&\n                y - _this.dotRadius < wall.y + wall.height &&\n                y + _this.dotRadius > wall.y;\n        });\n    };\n    AlternateDimension.prototype.isOverlappingDots = function (x, y, dots) {\n        var _this = this;\n        return dots.some(function (dot) {\n            return Math.sqrt(Math.pow(x - dot.x, 2) + Math.pow(y - dot.y, 2)) < (_this.dotRadius * 2);\n        });\n    };\n    AlternateDimension.prototype.isOverlappingPortal = function (x, y) {\n        var dx = x - this.regularPortalLocation.x;\n        var dy = y - this.regularPortalLocation.y;\n        return Math.sqrt(dx * dx + dy * dy) < (this.dotRadius + this.portalRadius);\n    };\n    AlternateDimension.prototype.createFixedMap = function () {\n        var walls = [\n            // Outer walls with openings\n            { x: 0, y: 0, width: this.width / 2 - 200, height: 200 },\n            { x: this.width / 2 + 200, y: 0, width: this.width / 2 - 200, height: 200 },\n            { x: 0, y: 0, width: 200, height: this.height / 2 - 200 },\n            { x: 0, y: this.height / 2 + 200, width: 200, height: this.height / 2 - 200 },\n            { x: this.width - 200, y: 0, width: 200, height: this.height / 2 - 200 },\n            { x: this.width - 200, y: this.height / 2 + 200, width: 200, height: this.height / 2 - 200 },\n            { x: 0, y: this.height - 200, width: this.width / 2 - 200, height: 200 },\n            { x: this.width / 2 + 200, y: this.height - 200, width: this.width / 2 - 200, height: 200 },\n            // Inner structures with openings\n            { x: 1000, y: 1000, width: 800, height: 300 },\n            { x: 1000, y: 1500, width: 300, height: 300 },\n            { x: 1500, y: 1500, width: 300, height: 300 },\n            { x: 1000, y: 1800, width: 800, height: 200 },\n            { x: 3000, y: 3000, width: 1000, height: 400 },\n            { x: 3000, y: 3400, width: 400, height: 600 },\n            { x: 3600, y: 3400, width: 400, height: 600 },\n            { x: 3000, y: 3900, width: 1000, height: 100 },\n            { x: 6000, y: 2000, width: 1500, height: 200 },\n            { x: 6000, y: 2200, width: 200, height: 300 },\n            { x: 7300, y: 2200, width: 200, height: 300 },\n            { x: 6000, y: 2400, width: 1500, height: 100 },\n            { x: 2000, y: 6000, width: 200, height: 1500 },\n            { x: 2200, y: 6000, width: 300, height: 200 },\n            { x: 2200, y: 7300, width: 300, height: 200 },\n            { x: 2400, y: 6000, width: 100, height: 1500 },\n            { x: 7000, y: 7000, width: 1200, height: 400 },\n            { x: 7000, y: 7400, width: 400, height: 800 },\n            { x: 7800, y: 7400, width: 400, height: 800 },\n            { x: 7000, y: 8100, width: 1200, height: 100 },\n            // Maze-like structures with openings\n            { x: 4000, y: 1000, width: 200, height: 800 },\n            { x: 4000, y: 2000, width: 200, height: 1000 },\n            { x: 4200, y: 1000, width: 800, height: 200 },\n            { x: 5200, y: 1000, width: 200, height: 200 },\n            { x: 5000, y: 1200, width: 200, height: 800 },\n            { x: 5000, y: 2200, width: 200, height: 800 },\n            { x: 4200, y: 2000, width: 600, height: 200 },\n            { x: 1000, y: 4000, width: 800, height: 200 },\n            { x: 2000, y: 4000, width: 1000, height: 200 },\n            { x: 1000, y: 4200, width: 200, height: 800 },\n            { x: 1000, y: 5200, width: 200, height: 200 },\n            { x: 1200, y: 5000, width: 800, height: 200 },\n            { x: 2200, y: 5000, width: 800, height: 200 },\n            { x: 2000, y: 4200, width: 200, height: 600 },\n            // Additional structures\n            // Central complex\n            { x: 4500, y: 4500, width: 1000, height: 1000 },\n            { x: 4700, y: 4500, width: 600, height: 200 },\n            { x: 4500, y: 4700, width: 200, height: 600 },\n            { x: 5300, y: 4700, width: 200, height: 600 },\n            { x: 4700, y: 5300, width: 600, height: 200 },\n            // Northwest quadrant\n            { x: 1000, y: 1000, width: 1500, height: 1500 },\n            { x: 1200, y: 1200, width: 1100, height: 1100 },\n            { x: 1400, y: 1000, width: 200, height: 200 },\n            { x: 1000, y: 1400, width: 200, height: 200 },\n            { x: 2300, y: 1400, width: 200, height: 200 },\n            { x: 1400, y: 2300, width: 200, height: 200 },\n            // Northeast quadrant\n            { x: 7500, y: 1000, width: 1500, height: 1500 },\n            { x: 7700, y: 1200, width: 1100, height: 1100 },\n            { x: 7900, y: 1000, width: 200, height: 200 },\n            { x: 7500, y: 1400, width: 200, height: 200 },\n            { x: 8800, y: 1400, width: 200, height: 200 },\n            { x: 7900, y: 2300, width: 200, height: 200 },\n            // Southwest quadrant\n            { x: 1000, y: 7500, width: 1500, height: 1500 },\n            { x: 1200, y: 7700, width: 1100, height: 1100 },\n            { x: 1400, y: 7500, width: 200, height: 200 },\n            { x: 1000, y: 7900, width: 200, height: 200 },\n            { x: 2300, y: 7900, width: 200, height: 200 },\n            { x: 1400, y: 8800, width: 200, height: 200 },\n            // Southeast quadrant\n            { x: 7500, y: 7500, width: 1500, height: 1500 },\n            { x: 7700, y: 7700, width: 1100, height: 1100 },\n            { x: 7900, y: 7500, width: 200, height: 200 },\n            { x: 7500, y: 7900, width: 200, height: 200 },\n            { x: 8800, y: 7900, width: 200, height: 200 },\n            { x: 7900, y: 8800, width: 200, height: 200 },\n            // Additional maze-like structures\n            { x: 3000, y: 3000, width: 1000, height: 100 },\n            { x: 3000, y: 3000, width: 100, height: 1000 },\n            { x: 3900, y: 3000, width: 100, height: 1000 },\n            { x: 3000, y: 3900, width: 1000, height: 100 },\n            { x: 3300, y: 3300, width: 400, height: 400 },\n            { x: 6000, y: 3000, width: 1000, height: 100 },\n            { x: 6000, y: 3000, width: 100, height: 1000 },\n            { x: 6900, y: 3000, width: 100, height: 1000 },\n            { x: 6000, y: 3900, width: 1000, height: 100 },\n            { x: 6300, y: 3300, width: 400, height: 400 },\n            { x: 3000, y: 6000, width: 1000, height: 100 },\n            { x: 3000, y: 6000, width: 100, height: 1000 },\n            { x: 3900, y: 6000, width: 100, height: 1000 },\n            { x: 3000, y: 6900, width: 1000, height: 100 },\n            { x: 3300, y: 6300, width: 400, height: 400 },\n            { x: 6000, y: 6000, width: 1000, height: 100 },\n            { x: 6000, y: 6000, width: 100, height: 1000 },\n            { x: 6900, y: 6000, width: 100, height: 1000 },\n            { x: 6000, y: 6900, width: 1000, height: 100 },\n            { x: 6300, y: 6300, width: 400, height: 400 },\n            // Connecting corridors\n            { x: 2500, y: 4900, width: 5000, height: 200 },\n            { x: 4900, y: 2500, width: 200, height: 5000 },\n        ];\n        return walls;\n    };\n    AlternateDimension.prototype.findSafePortalLocation = function () {\n        var x = 0;\n        var y = 0;\n        var isSafe = false;\n        while (!isSafe) {\n            if (this.dimensionType === DimensionType.Grass) {\n                var randomIsland = this.islands[Math.floor(Math.random() * this.islands.length)];\n                var angle = Math.random() * 2 * Math.PI;\n                var distance = Math.random() * randomIsland.radius;\n                x = randomIsland.x + distance * Math.cos(angle);\n                y = randomIsland.y + distance * Math.sin(angle);\n                isSafe = this.isOnIslandOrBridge(x, y);\n            }\n            else {\n                x = Math.random() * this.width;\n                y = Math.random() * this.height;\n                isSafe = !this.isInsideWall(x, y);\n            }\n        }\n        return { x: x, y: y };\n    };\n    AlternateDimension.prototype.update = function (player, entities, deltaTime) {\n        var _this = this;\n        // Check if player is digging any dots\n        var playerRadius = player.getSize() / 2;\n        this.dots.forEach(function (dot) {\n            if (dot.present) {\n                var dx = player.getX() - dot.x;\n                var dy = player.getY() - dot.y;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                if (distance <= playerRadius + _this.dotRadius) {\n                    dot.present = false;\n                    player.adjustAlternateDimensionScore(1000); // Give 1000 points for each dot\n                }\n            }\n        });\n        // Check for collisions with walls\n        this.walls.forEach(function (wall) {\n            if (_this.checkCollisionWithWall(player, wall)) {\n                _this.resolveCollision(player, wall);\n            }\n        });\n        if (this.dimensionType === DimensionType.Grass) {\n            this.updateGrassDimension(player);\n            this.updateBumbleBees(player, deltaTime);\n        }\n        // Update entities (enemies or cloud mobs)\n        entities.forEach(function (entity) {\n            if (_this.checkCollision(entity, player)) {\n                _this.resolveEntityCollision(entity, player);\n            }\n        });\n    };\n    AlternateDimension.prototype.updateGrassDimension = function (player) {\n        // Check if player is on grass\n        var playerOnGrass = this.grassPatches.some(function (patch) {\n            var dx = player.getX() - patch.x;\n            var dy = player.getY() - patch.y;\n            return Math.sqrt(dx * dx + dy * dy) <= patch.radius;\n        });\n        if (playerOnGrass) {\n            player.recoverHealth(0.1); // Heal player slightly when on grass\n        }\n    };\n    AlternateDimension.prototype.checkCollision = function (entity1, entity2) {\n        var dx = entity1.getX() - entity2.getX();\n        var dy = entity1.getY() - entity2.getY();\n        var distance = Math.sqrt(dx * dx + dy * dy);\n        return distance < (entity1.getSize() + entity2.getSize()) / 2;\n    };\n    AlternateDimension.prototype.checkCollisionWithWall = function (entity, wall) {\n        var entityLeft = entity.getX() - entity.getSize() / 2;\n        var entityRight = entity.getX() + entity.getSize() / 2;\n        var entityTop = entity.getY() - entity.getSize() / 2;\n        var entityBottom = entity.getY() + entity.getSize() / 2;\n        return entityLeft < wall.x + wall.width &&\n            entityRight > wall.x &&\n            entityTop < wall.y + wall.height &&\n            entityBottom > wall.y;\n    };\n    AlternateDimension.prototype.resolveCollision = function (player, wall) {\n        var playerSize = player.getSize();\n        var playerCenterX = player.getX();\n        var playerCenterY = player.getY();\n        var wallCenterX = wall.x + wall.width / 2;\n        var wallCenterY = wall.y + wall.height / 2;\n        var dx = playerCenterX - wallCenterX;\n        var dy = playerCenterY - wallCenterY;\n        if (Math.abs(dx / wall.width) > Math.abs(dy / wall.height)) {\n            // Collision on the x-axis\n            if (dx > 0) {\n                player.setPosition(wall.x + wall.width + playerSize / 2, player.getY());\n            }\n            else {\n                player.setPosition(wall.x - playerSize / 2, player.getY());\n            }\n        }\n        else {\n            // Collision on the y-axis\n            if (dy > 0) {\n                player.setPosition(player.getX(), wall.y + wall.height + playerSize / 2);\n            }\n            else {\n                player.setPosition(player.getX(), wall.y - playerSize / 2);\n            }\n        }\n    };\n    AlternateDimension.prototype.resolveEntityCollision = function (entity, player) {\n        // Handle collision based on entity type\n        if (entity instanceof enemy_1.Enemy) {\n            // Existing enemy collision logic\n            var damage = Math.floor(entity.getSize() * 0.5);\n            player.takeDamage(damage);\n        }\n        else if (entity instanceof cloudMob_1.CloudMob) {\n            // Cloud mob collision logic (no damage, just bounce)\n            var dx = player.getX() - entity.getX();\n            var dy = player.getY() - entity.getY();\n            var distance = Math.sqrt(dx * dx + dy * dy);\n            var bounceDistance = 20;\n            var bounceX = entity.getX() + (dx / distance) * bounceDistance;\n            var bounceY = entity.getY() + (dy / distance) * bounceDistance;\n            entity.setPosition(bounceX, bounceY);\n        }\n    };\n    AlternateDimension.prototype.render = function (context, player, canvasWidth, canvasHeight, zoom) {\n        if (this.dimensionType === DimensionType.Dark) {\n            this.renderDarkDimension(context, player, canvasWidth, canvasHeight, zoom);\n        }\n        else {\n            this.renderGrassDimension(context, player, canvasWidth, canvasHeight, zoom);\n        }\n    };\n    AlternateDimension.prototype.renderDarkDimension = function (context, player, canvasWidth, canvasHeight, zoom) {\n        var _this = this;\n        // Fill the entire visible area with a dark background\n        context.fillStyle = '#000033'; // Dark blue background\n        context.fillRect(player.getX() - canvasWidth / (2 * zoom), player.getY() - canvasHeight / (2 * zoom), canvasWidth / zoom, canvasHeight / zoom);\n        // Draw the walls\n        context.fillStyle = 'white';\n        this.walls.forEach(function (wall) {\n            context.fillRect(wall.x, wall.y, wall.width, wall.height);\n        });\n        // Draw the diggable dots\n        context.fillStyle = '#FFD700'; // Gold color for the dots\n        this.dots.forEach(function (dot) {\n            if (dot.present) {\n                context.beginPath();\n                context.arc(dot.x, dot.y, _this.dotRadius, 0, Math.PI * 2);\n                context.fill();\n            }\n        });\n        // Draw the portals\n        context.fillStyle = '#00BFFF'; // Light blue color for portals\n        context.beginPath();\n        context.arc(this.regularPortalLocation.x, this.regularPortalLocation.y, this.portalRadius, 0, Math.PI * 2);\n        context.fill();\n        context.beginPath();\n        context.arc(this.grassPortalLocation.x, this.grassPortalLocation.y, this.portalRadius, 0, Math.PI * 2);\n        context.fill();\n    };\n    AlternateDimension.prototype.renderGrassDimension = function (context, player, canvasWidth, canvasHeight, zoom) {\n        var _this = this;\n        // Fill the entire visible area with a light blue background (water)\n        context.fillStyle = '#87CEEB';\n        context.fillRect(player.getX() - canvasWidth / (2 * zoom), player.getY() - canvasHeight / (2 * zoom), canvasWidth / zoom, canvasHeight / zoom);\n        // Draw islands\n        context.fillStyle = '#228B22'; // Forest green for islands\n        this.islands.forEach(function (island) {\n            context.beginPath();\n            context.arc(island.x, island.y, island.radius, 0, Math.PI * 2);\n            context.fill();\n        });\n        // Draw bridges\n        context.strokeStyle = '#8B4513'; // Saddle Brown for bridges\n        this.bridges.forEach(function (bridge) {\n            context.beginPath();\n            context.moveTo(bridge.start.x, bridge.start.y);\n            context.lineTo(bridge.end.x, bridge.end.y);\n            context.lineWidth = bridge.width;\n            context.stroke();\n        });\n        // Draw grass patches on islands\n        context.fillStyle = '#32CD32'; // Lime green for grass patches\n        this.grassPatches.forEach(function (patch) {\n            if (_this.isInsideIsland(patch.x, patch.y)) {\n                context.beginPath();\n                context.arc(patch.x, patch.y, patch.radius, 0, Math.PI * 2);\n                context.fill();\n            }\n        });\n        // Draw the diggable dots (as flowers in this dimension)\n        context.fillStyle = '#FF69B4'; // Hot Pink for flowers\n        this.dots.forEach(function (dot) {\n            if (dot.present) {\n                context.beginPath();\n                context.arc(dot.x, dot.y, _this.dotRadius, 0, Math.PI * 2);\n                context.fill();\n            }\n        });\n        // Draw the portals\n        context.fillStyle = '#00BFFF'; // Light blue color for portals\n        context.beginPath();\n        context.arc(this.regularPortalLocation.x, this.regularPortalLocation.y, this.portalRadius, 0, Math.PI * 2);\n        context.fill();\n        context.beginPath();\n        context.arc(this.grassPortalLocation.x, this.grassPortalLocation.y, this.portalRadius, 0, Math.PI * 2);\n        context.fill();\n        // Draw bumble bees\n        this.bumbleBees.forEach(function (bee) { return bee.draw(); });\n    };\n    AlternateDimension.prototype.getRegularPortalLocation = function () {\n        return this.regularPortalLocation;\n    };\n    AlternateDimension.prototype.getGrassPortalLocation = function () {\n        return this.grassPortalLocation;\n    };\n    AlternateDimension.prototype.getWalls = function () {\n        return this.walls;\n    };\n    AlternateDimension.prototype.getWidth = function () {\n        return this.width;\n    };\n    AlternateDimension.prototype.getHeight = function () {\n        return this.height;\n    };\n    AlternateDimension.prototype.generateNewPortalLocation = function () {\n        this.regularPortalLocation = this.findSafePortalLocation();\n        this.grassPortalLocation = this.findSafePortalLocation();\n    };\n    AlternateDimension.prototype.setDimensionType = function (type) {\n        this.dimensionType = type;\n    };\n    AlternateDimension.prototype.getDimensionType = function () {\n        return this.dimensionType;\n    };\n    AlternateDimension.prototype.getGrassPatches = function () {\n        return this.grassPatches;\n    };\n    AlternateDimension.prototype.getIslands = function () {\n        return this.islands;\n    };\n    AlternateDimension.prototype.getBridges = function () {\n        return this.bridges;\n    };\n    // Add a method to check if a move is valid\n    AlternateDimension.prototype.isValidMove = function (x, y) {\n        return this.dimensionType === DimensionType.Dark || this.isOnIslandOrBridge(x, y);\n    };\n    AlternateDimension.prototype.generateBumbleBees = function () {\n        var _this = this;\n        var beeCount = 20; // Adjust this number as needed\n        this.islands.forEach(function (island) {\n            for (var i = 0; i < beeCount / _this.islands.length; i++) {\n                var angle = Math.random() * Math.PI * 2;\n                var distance = Math.random() * (island.radius - _this.dotRadius);\n                var x = island.x + Math.cos(angle) * distance;\n                var y = island.y + Math.sin(angle) * distance;\n                _this.bumbleBees.push(new bumbleBee_1.BumbleBee(x, y, _this.context, _this.player, _this.terrain, island, _this.game));\n            }\n        });\n    };\n    AlternateDimension.prototype.updateBumbleBees = function (player, deltaTime) {\n        this.bumbleBees = this.bumbleBees.filter(function (bee) { return !bee.isDead(); });\n        this.bumbleBees.forEach(function (bee) {\n            bee.update(deltaTime);\n            // Check for collision with player\n            var dx = player.getX() - bee.getX();\n            var dy = player.getY() - bee.getY();\n            var distance = Math.sqrt(dx * dx + dy * dy);\n            if (distance < (player.getSize() + bee.getSize()) / 2) {\n                if (!bee.isAngered()) {\n                    bee.anger();\n                }\n                else {\n                    var playerMaxHealth = player.getHealth();\n                    var damage = Math.floor(playerMaxHealth * 0.75); // 3/4 of player's max health\n                    player.takeDamage(damage);\n                    bee.takeDamage(10); // Player deals 10 damage to the bee\n                }\n            }\n            // Player can damage bees when they're close\n            if (distance < player.getSize() * 1.5) {\n                bee.takeDamage(1); // Player deals 1 damage to the bee when close\n            }\n        });\n        // Spawn new bees if needed\n        while (this.bumbleBees.length < 20) {\n            var island = this.islands[Math.floor(Math.random() * this.islands.length)];\n            var angle = Math.random() * Math.PI * 2;\n            var distance = Math.random() * (island.radius - this.dotRadius);\n            var x = island.x + Math.cos(angle) * distance;\n            var y = island.y + Math.sin(angle) * distance;\n            this.bumbleBees.push(new bumbleBee_1.BumbleBee(x, y, this.context, player, this.terrain, island, this.game));\n        }\n    };\n    // Add a getter for bumble bees\n    AlternateDimension.prototype.getBumbleBees = function () {\n        return this.bumbleBees;\n    };\n    // Add this method to the AlternateDimension class\n    AlternateDimension.prototype.setBumbleBees = function (bees) {\n        this.bumbleBees = bees;\n    };\n    return AlternateDimension;\n}());\nexports.AlternateDimension = AlternateDimension;\n\n\n//# sourceURL=webpack:///./src/alternateDimension.ts?");

/***/ }),

/***/ "./src/bumbleBee.ts":
/*!**************************!*\
  !*** ./src/bumbleBee.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BumbleBee = void 0;\nvar BumbleBee = /** @class */ (function () {\n    function BumbleBee(x, y, context, player, terrain, island, game) {\n        this.size = 15;\n        this.isAngry = false;\n        this.angerTimer = 0;\n        this.ANGER_DURATION = 5000; // 5 seconds of anger\n        this.health = 100;\n        this.attackCooldown = 0;\n        this.attackInterval = 1000; // 1 second between attacks\n        this.maxChaseDistance = 500; // Maximum distance to chase the player\n        this.idleAngle = Math.random() * Math.PI * 2;\n        this.idleSpeed = 20; // Reduced from 30 to 20\n        this.retreatDistance = 100; // Distance to retreat after attacking\n        this.isBuzzing = false;\n        this.x = x;\n        this.y = y;\n        this.context = context;\n        this.player = player;\n        this.terrain = terrain;\n        this.currentIsland = island;\n        this.game = game;\n    }\n    BumbleBee.prototype.update = function (deltaTime) {\n        var deltaSeconds = Math.min(deltaTime / 1000, 0.1); // Cap delta time to prevent large jumps\n        var dx = this.player.getX() - this.x;\n        var dy = this.player.getY() - this.y;\n        var distanceToPlayer = Math.sqrt(dx * dx + dy * dy);\n        if (this.isAngry) {\n            this.angerTimer += deltaTime;\n            if (this.angerTimer >= this.ANGER_DURATION) {\n                this.calmDown();\n            }\n            else {\n                this.updateAngryBehavior(distanceToPlayer, deltaSeconds);\n            }\n        }\n        else {\n            this.updateIdleBehavior(deltaSeconds);\n            // Check if player is close enough to anger the bee\n            if (distanceToPlayer < 100) {\n                this.anger();\n            }\n        }\n        // Keep within terrain boundaries\n        this.x = Math.max(this.size, Math.min(this.x, this.terrain.getWidth() - this.size));\n        this.y = Math.max(this.size, Math.min(this.y, this.terrain.getHeight() - this.size));\n    };\n    BumbleBee.prototype.updateAngryBehavior = function (distanceToPlayer, deltaSeconds) {\n        if (distanceToPlayer > this.maxChaseDistance) {\n            this.calmDown();\n        }\n        else {\n            var moveSpeed = this.player.getSpeed() * 75; // Reduced from 100 to 75 times player's speed\n            var angle = Math.atan2(this.player.getY() - this.y, this.player.getX() - this.x);\n            this.x += Math.cos(angle) * moveSpeed * deltaSeconds;\n            this.y += Math.sin(angle) * moveSpeed * deltaSeconds;\n            this.attackCooldown -= deltaSeconds * 1000;\n            if (this.attackCooldown <= 0 && distanceToPlayer < this.size + 20) {\n                this.attackPlayer();\n                this.attackCooldown = this.attackInterval;\n                this.retreatAfterAttack();\n            }\n        }\n    };\n    BumbleBee.prototype.updateIdleBehavior = function (deltaSeconds) {\n        this.idleAngle += (Math.random() - 0.5) * 0.1;\n        var newX = this.x + Math.cos(this.idleAngle) * this.idleSpeed * deltaSeconds;\n        var newY = this.y + Math.sin(this.idleAngle) * this.idleSpeed * deltaSeconds;\n        var distanceToIslandCenter = Math.sqrt(Math.pow(newX - this.currentIsland.x, 2) +\n            Math.pow(newY - this.currentIsland.y, 2));\n        if (distanceToIslandCenter <= this.currentIsland.radius - this.size) {\n            this.x = newX;\n            this.y = newY;\n        }\n        else {\n            this.idleAngle = Math.atan2(this.currentIsland.y - this.y, this.currentIsland.x - this.x);\n        }\n    };\n    BumbleBee.prototype.attackPlayer = function () {\n        var playerCurrentHealth = this.player.getHealth();\n        var damage = Math.floor(playerCurrentHealth * 0.75); // 3/4 of player's current health\n        this.player.takeDamage(damage);\n        console.log(\"Bee attacked player for \".concat(damage, \" damage. Player health: \").concat(this.player.getHealth()));\n    };\n    BumbleBee.prototype.retreatAfterAttack = function () {\n        var angle = Math.atan2(this.y - this.player.getY(), this.x - this.player.getX());\n        var newX = this.x + Math.cos(angle) * this.retreatDistance;\n        var newY = this.y + Math.sin(angle) * this.retreatDistance;\n        // Ensure the new position is within the terrain boundaries\n        this.x = Math.max(this.size, Math.min(newX, this.terrain.getWidth() - this.size));\n        this.y = Math.max(this.size, Math.min(newY, this.terrain.getHeight() - this.size));\n    };\n    BumbleBee.prototype.draw = function () {\n        this.context.save();\n        // Draw the main body\n        this.context.fillStyle = this.isAngry ? 'red' : 'yellow';\n        this.context.beginPath();\n        this.context.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n        this.context.fill();\n        // Draw stripes\n        this.context.fillStyle = 'black';\n        var stripeCount = 3;\n        var stripeWidth = this.size * 0.4; // Adjust this value to change stripe width\n        var stripeSpacing = this.size * 0.5; // Adjust this value to change stripe spacing\n        for (var i = 0; i < stripeCount; i++) {\n            this.context.save();\n            this.context.translate(this.x, this.y);\n            this.context.rotate(Math.PI / 4); // Rotate stripes diagonally\n            // Calculate stripe position\n            var stripeX = -this.size + (i + 0.5) * stripeSpacing - stripeWidth / 2;\n            // Use a clipping region to keep stripes inside the bee\n            this.context.beginPath();\n            this.context.arc(0, 0, this.size, 0, Math.PI * 2);\n            this.context.clip();\n            // Draw the stripe\n            this.context.fillRect(stripeX, -this.size, stripeWidth, this.size * 2);\n            this.context.restore();\n        }\n        // Draw antennae\n        this.context.strokeStyle = 'black';\n        this.context.lineWidth = this.size * 0.1;\n        // Left antenna\n        this.context.beginPath();\n        this.context.moveTo(this.x + this.size * 0.3, this.y - this.size * 0.5);\n        this.context.lineTo(this.x + this.size * 0.6, this.y - this.size * 0.9);\n        this.context.stroke();\n        // Right antenna\n        this.context.beginPath();\n        this.context.moveTo(this.x + this.size * 0.5, this.y - this.size * 0.3);\n        this.context.lineTo(this.x + this.size * 0.9, this.y - this.size * 0.6);\n        this.context.stroke();\n        this.context.restore();\n    };\n    BumbleBee.prototype.getX = function () { return this.x; };\n    BumbleBee.prototype.getY = function () { return this.y; };\n    BumbleBee.prototype.getSize = function () { return this.size; };\n    BumbleBee.prototype.anger = function () {\n        if (!this.isAngry) {\n            this.isAngry = true;\n            this.angerTimer = 0;\n            this.game.getSoundManager().playAngryBeeSound();\n            this.isBuzzing = true;\n        }\n    };\n    BumbleBee.prototype.calmDown = function () {\n        if (this.isAngry) {\n            this.isAngry = false;\n            this.angerTimer = 0;\n            this.stopBuzzing();\n        }\n    };\n    BumbleBee.prototype.stopBuzzing = function () {\n        if (this.isBuzzing) {\n            this.game.getSoundManager().stopAngryBeeSound();\n            this.isBuzzing = false;\n        }\n    };\n    BumbleBee.prototype.isAngered = function () { return this.isAngry; };\n    BumbleBee.prototype.takeDamage = function (amount) {\n        this.health -= amount;\n        if (this.health <= 0) {\n            this.health = 0;\n        }\n    };\n    BumbleBee.prototype.isDead = function () { return this.health <= 0; };\n    BumbleBee.prototype.getHealth = function () { return this.health; };\n    return BumbleBee;\n}());\nexports.BumbleBee = BumbleBee;\n\n\n//# sourceURL=webpack:///./src/bumbleBee.ts?");

/***/ }),

/***/ "./src/cloudMob.ts":
/*!*************************!*\
  !*** ./src/cloudMob.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CloudMob = void 0;\nvar CloudMob = /** @class */ (function () {\n    function CloudMob(x, y, size, health, context, player, terrain) {\n        this.x = x;\n        this.y = y;\n        this.size = size;\n        this.health = health;\n        this.maxHealth = health;\n        this.speedX = (Math.random() - 0.5) * 2; // Random speed between -1 and 1\n        this.speedY = (Math.random() - 0.5) * 2; // Random speed between -1 and 1\n        this.context = context;\n        this.player = player;\n        this.terrain = terrain;\n    }\n    CloudMob.prototype.update = function (deltaTime) {\n        // Move the cloud mob\n        this.x += this.speedX * deltaTime / 16; // Adjust speed based on 60 FPS\n        this.y += this.speedY * deltaTime / 16;\n        // Bounce off terrain boundaries\n        if (this.x - this.size / 2 < 0 || this.x + this.size / 2 > this.terrain.getWidth()) {\n            this.speedX = -this.speedX;\n        }\n        if (this.y - this.size / 2 < 0 || this.y + this.size / 2 > this.terrain.getHeight()) {\n            this.speedY = -this.speedY;\n        }\n        // Ensure the cloud stays within the terrain boundaries\n        this.x = Math.max(this.size / 2, Math.min(this.x, this.terrain.getWidth() - this.size / 2));\n        this.y = Math.max(this.size / 2, Math.min(this.y, this.terrain.getHeight() - this.size / 2));\n    };\n    CloudMob.prototype.draw = function () {\n        // Draw the cloud as a simple circle\n        this.context.save();\n        this.context.fillStyle = 'rgba(255, 255, 255, 0.7)';\n        this.context.beginPath();\n        this.context.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n        this.context.fill();\n        // Draw health bar\n        var healthBarWidth = this.size * 2;\n        var healthBarHeight = 5;\n        var healthPercentage = this.health / this.maxHealth;\n        this.context.fillStyle = 'red';\n        this.context.fillRect(this.x - healthBarWidth / 2, this.y - this.size - 10, healthBarWidth, healthBarHeight);\n        this.context.fillStyle = 'green';\n        this.context.fillRect(this.x - healthBarWidth / 2, this.y - this.size - 10, healthBarWidth * healthPercentage, healthBarHeight);\n        this.context.restore();\n    };\n    CloudMob.prototype.getX = function () {\n        return this.x;\n    };\n    CloudMob.prototype.getY = function () {\n        return this.y;\n    };\n    CloudMob.prototype.getSize = function () {\n        return this.size;\n    };\n    CloudMob.prototype.takeDamage = function (amount) {\n        this.health = Math.max(0, this.health - amount);\n    };\n    CloudMob.prototype.isDead = function () {\n        return this.health <= 0;\n    };\n    CloudMob.prototype.setPosition = function (x, y) {\n        this.x = x;\n        this.y = y;\n    };\n    CloudMob.prototype.bounceOff = function (otherX, otherY) {\n        var dx = this.x - otherX;\n        var dy = this.y - otherY;\n        var distance = Math.sqrt(dx * dx + dy * dy);\n        var bounceSpeed = 5; // Adjust this value to change the bounce strength\n        this.speedX = (dx / distance) * bounceSpeed;\n        this.speedY = (dy / distance) * bounceSpeed;\n    };\n    CloudMob.prototype.getHealth = function () {\n        return this.health;\n    };\n    return CloudMob;\n}());\nexports.CloudMob = CloudMob;\n\n\n//# sourceURL=webpack:///./src/cloudMob.ts?");

/***/ }),

/***/ "./src/enemy.ts":
/*!**********************!*\
  !*** ./src/enemy.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Enemy = void 0;\nvar player_1 = __webpack_require__(/*! ./player */ \"./src/player.ts\");\nvar Enemy = /** @class */ (function (_super) {\n    __extends(Enemy, _super);\n    function Enemy(x, y, terrainWidth, terrainHeight, context, target, terrain, game) {\n        var _this = _super.call(this, x, y, 100, 5, context, terrain, game) || this;\n        _this.randomDirection = { x: 0, y: 0 };\n        _this.randomMovementDuration = 0;\n        _this.goldDetectionRadius = 100; // Radius to detect gold\n        _this.target = target;\n        _this.setSize(30); // Start with a smaller size\n        return _this;\n    }\n    // Change protected to public\n    Enemy.prototype.getSpeed = function () {\n        return _super.prototype.getSpeed.call(this) * 0.2; // 20% of the player's speed\n    };\n    Enemy.prototype.update = function (terrain, screenWidth, screenHeight, cameraX, cameraY) {\n        _super.prototype.update.call(this, terrain, screenWidth, screenHeight, cameraX, cameraY);\n        if (this.isOffScreen(screenWidth, screenHeight, cameraX, cameraY)) {\n            this.moveRandomly();\n        }\n        else {\n            this.moveTowardsTarget(terrain);\n        }\n        // Remove the digging logic from here, as it's now handled in the Game class\n        this.updateRingRotation();\n        // Randomly display emotes\n        if (Math.random() < 0.001) { // 0.1% chance each update\n            var randomEmote = Math.floor(Math.random() * Object.keys(player_1.Emote).length / 2);\n            this.displayEmote(randomEmote);\n        }\n    };\n    Enemy.prototype.updateEmote = function (deltaTime) {\n        _super.prototype.updateEmote.call(this, deltaTime);\n    };\n    Enemy.prototype.isOffScreen = function (screenWidth, screenHeight, cameraX, cameraY) {\n        return this.getX() < cameraX || this.getX() > cameraX + screenWidth ||\n            this.getY() < cameraY || this.getY() > cameraY + screenHeight;\n    };\n    Enemy.prototype.moveRandomly = function () {\n        if (this.randomMovementDuration <= 0) {\n            var angle = Math.random() * 2 * Math.PI;\n            this.randomDirection = {\n                x: Math.cos(angle),\n                y: Math.sin(angle)\n            };\n            this.randomMovementDuration = Math.random() * 100 + 50;\n        }\n        var speed = this.getSpeed();\n        this.move(this.randomDirection.x * speed, this.randomDirection.y * speed);\n        this.randomMovementDuration--;\n    };\n    Enemy.prototype.moveTowardsTarget = function (terrain) {\n        var nearestGold = this.findNearestGold(terrain);\n        var targetX, targetY;\n        if (nearestGold) {\n            targetX = nearestGold.x;\n            targetY = nearestGold.y;\n        }\n        else {\n            targetX = this.target.getX();\n            targetY = this.target.getY();\n        }\n        var dx = targetX - this.getX();\n        var dy = targetY - this.getY();\n        var distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance > 0) {\n            var speed = this.getSpeed();\n            var moveX = (dx / distance) * speed;\n            var moveY = (dy / distance) * speed;\n            this.move(moveX, moveY);\n        }\n    };\n    Enemy.prototype.findNearestGold = function (terrain) {\n        var startX = Math.floor((this.getX() - this.goldDetectionRadius) / 10);\n        var startY = Math.floor((this.getY() - this.goldDetectionRadius) / 10);\n        var endX = Math.ceil((this.getX() + this.goldDetectionRadius) / 10);\n        var endY = Math.ceil((this.getY() + this.goldDetectionRadius) / 10);\n        var nearestGold = null;\n        var nearestDistance = Infinity;\n        for (var x = startX; x <= endX; x++) {\n            for (var y = startY; y <= endY; y++) {\n                var block = terrain.getBlock(x * 10, y * 10);\n                if (block && block.type === 'gold_ore' && block.present) {\n                    var dx = x * 10 - this.getX();\n                    var dy = y * 10 - this.getY();\n                    var distance = Math.sqrt(dx * dx + dy * dy);\n                    if (distance < nearestDistance) {\n                        nearestDistance = distance;\n                        nearestGold = { x: x * 10, y: y * 10 };\n                    }\n                }\n            }\n        }\n        return nearestGold;\n    };\n    Enemy.prototype.handleDugBlock = function (block) {\n        switch (block.type) {\n            case 'uranium':\n                this.adjustHealth(-2); // Reduced damage from uranium\n                break;\n            case 'lava':\n                this.adjustHealth(-10); // Reduced damage from lava\n                break;\n            case 'quartz':\n                this.adjustShield(5);\n                break;\n            case 'bedrock':\n                this.adjustScore(5);\n                break;\n            case 'gold_ore':\n                this.adjustGoldScore(1);\n                break;\n            default:\n                this.adjustScore(1);\n        }\n        this.updateSize();\n    };\n    Enemy.prototype.updateSize = function () {\n        this.setSize(this.getScore() + this.getGoldScore());\n    };\n    Enemy.prototype.setSize = function (score) {\n        var minSize = 20;\n        var growthFactor = 1.5;\n        var levelBonus = (this.getLevel() - 1) * 0.1;\n        var newSize = (minSize + Math.sqrt(score) * growthFactor) * (1 + levelBonus);\n        _super.prototype.setSize.call(this, Math.max(minSize, Math.min(1000, newSize))); // Use 1000 as max size\n    };\n    // Override the getLevel method to provide a level for the enemy\n    Enemy.prototype.getLevel = function () {\n        return Math.floor(Math.sqrt(this.getScore() / 100)) + 1;\n    };\n    Enemy.prototype.setPosition = function (x, y) {\n        this.x = x;\n        this.y = y;\n    };\n    // Override the draw method to change the color of the enemy and make a shorter frown\n    Enemy.prototype.draw = function (visibleWidth, visibleHeight) {\n        _super.prototype.draw.call(this, visibleWidth, visibleHeight);\n        // Add any enemy-specific drawing code here\n        // For example, you might want to change the color or add some distinguishing feature\n        var context = this.getContext();\n        var x = this.getX();\n        var y = this.getY();\n        var size = this.getSize();\n        // Draw a red outline for the enemy\n        context.strokeStyle = 'red';\n        context.lineWidth = 2;\n        context.beginPath();\n        context.arc(x, y, size / 2 + 2, 0, Math.PI * 2);\n        context.stroke();\n    };\n    return Enemy;\n}(player_1.Player));\nexports.Enemy = Enemy;\n\n\n//# sourceURL=webpack:///./src/enemy.ts?");

/***/ }),

/***/ "./src/game.ts":
/*!*********************!*\
  !*** ./src/game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Game = void 0;\nvar player_1 = __webpack_require__(/*! ./player */ \"./src/player.ts\");\nvar enemy_1 = __webpack_require__(/*! ./enemy */ \"./src/enemy.ts\");\nvar terrain_1 = __webpack_require__(/*! ./terrain */ \"./src/terrain.ts\");\nvar shop_1 = __webpack_require__(/*! ./shop */ \"./src/shop.ts\");\nvar alternateDimension_1 = __webpack_require__(/*! ./alternateDimension */ \"./src/alternateDimension.ts\");\nvar cloudMob_1 = __webpack_require__(/*! ./cloudMob */ \"./src/cloudMob.ts\");\nvar soundManager_1 = __webpack_require__(/*! ./soundManager */ \"./src/soundManager.ts\");\nvar Game = /** @class */ (function () {\n    function Game(canvasId, titleScreen) {\n        this.enemies = [];\n        this.maxEnemies = 40;\n        this.isMouseControl = false;\n        this.zoom = 1;\n        this.minZoom = 0.01;\n        this.maxZoom = 1;\n        this.zoomCap = 0.4;\n        this.lastUpdateTime = 0;\n        this.isEmoteWheelOpen = false;\n        this.emoteWheelRadius = 100;\n        this.selectedEmote = null;\n        this.alternateDimension = null;\n        this.grassDimension = null;\n        this.currentDimension = 'normal';\n        this.portalCooldown = 0;\n        this.PORTAL_COOLDOWN_DURATION = 5000;\n        this.isGameOver = false;\n        this.gameOverMessage = '';\n        this.cloudMobs = [];\n        this.maxCloudMobs = 20;\n        this.lastDamageSource = 'unknown';\n        this.isMuted = false;\n        this.canvas = document.getElementById(canvasId);\n        this.context = this.canvas.getContext('2d');\n        this.terrain = new terrain_1.Terrain(10000, 10000);\n        var portalLocation = this.terrain.getPortalLocation();\n        // Reduced spawn distance from the portal for easier debugging\n        var minSpawnDistance = 100; // Changed from 1000 to 100\n        var maxSpawnDistance = 200; // Added max spawn distance\n        var spawnX, spawnY;\n        do {\n            var angle = Math.random() * 2 * Math.PI;\n            var distance = minSpawnDistance + Math.random() * (maxSpawnDistance - minSpawnDistance);\n            spawnX = portalLocation.x + Math.cos(angle) * distance;\n            spawnY = portalLocation.y + Math.sin(angle) * distance;\n        } while (spawnX < 0 || spawnX >= this.terrain.getWidth() ||\n            spawnY < 0 || spawnY >= this.terrain.getHeight());\n        this.player = new player_1.Player(spawnX, spawnY, 100, 10, this.context, this.terrain, this);\n        this.score = 0;\n        this.keysPressed = new Set();\n        this.cameraX = 0;\n        this.cameraY = 0;\n        this.lastHealthRecoveryTime = Date.now();\n        this.enemies = [];\n        this.spawnEnemies(20);\n        this.shop = new shop_1.Shop(this.player, this.context, this);\n        this.alternateDimension = new alternateDimension_1.AlternateDimension(10000, 10000, this.context, alternateDimension_1.DimensionType.Dark, this.player, this.terrain, this);\n        this.grassDimension = new alternateDimension_1.AlternateDimension(10000, 10000, this.context, alternateDimension_1.DimensionType.Grass, this.player, this.terrain, this);\n        this.titleScreen = titleScreen;\n        this.soundManager = new soundManager_1.SoundManager();\n        this.volumeSlider = this.createVolumeSlider();\n        this.muteButton = this.createMuteButton();\n        this.soundManager.playBackgroundMusic();\n        this.init();\n        this.loadSettings();\n        this.applySettings();\n    }\n    Game.prototype.init = function () {\n        var _this = this;\n        window.addEventListener('keydown', function (e) { return _this.handleKeyDown(e); });\n        window.addEventListener('keyup', function (e) { return _this.handleKeyUp(e); });\n        this.canvas.addEventListener('mousemove', function (e) { return _this.handleMouseMove(e); });\n        this.canvas.addEventListener('mousedown', function (e) { return _this.handleMouseDown(e); });\n        this.canvas.addEventListener('mouseup', function (e) { return _this.handleMouseUp(e); });\n        window.addEventListener('keydown', function (e) { return _this.handleEmoteInput(e); });\n        this.resizeCanvas();\n        this.gameLoop();\n        this.lastUpdateTime = Date.now();\n    };\n    Game.prototype.resizeCanvas = function () {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n    };\n    Game.prototype.handleKeyDown = function (event) {\n        if (event.key === 'e') {\n            this.toggleEmoteWheel();\n        }\n        else if (event.key === 's') {\n            this.shop.toggleShop();\n        }\n        this.keysPressed.add(event.key);\n    };\n    Game.prototype.handleKeyUp = function (event) {\n        this.keysPressed.delete(event.key);\n    };\n    Game.prototype.handleMouseMove = function (event) {\n        if (this.isEmoteWheelOpen) {\n            var rect = this.canvas.getBoundingClientRect();\n            var x = event.clientX - rect.left;\n            var y = event.clientY - rect.top;\n            this.selectedEmote = this.getEmoteFromPosition(x, y);\n        }\n        else if (this.isMouseControl) {\n            var rect = this.canvas.getBoundingClientRect();\n            var mouseX = event.clientX - rect.left;\n            var mouseY = event.clientY - rect.top;\n            var worldX = (mouseX / this.zoom) + this.cameraX;\n            var worldY = (mouseY / this.zoom) + this.cameraY;\n            var dx = worldX - this.player.getX();\n            var dy = worldY - this.player.getY();\n            var distance = Math.sqrt(dx * dx + dy * dy);\n            if (distance > 5) {\n                var angle = Math.atan2(dy, dx);\n                var moveX = Math.cos(angle);\n                var moveY = Math.sin(angle);\n                var newX = this.player.getX() + moveX * this.player.getSpeed();\n                var newY = this.player.getY() + moveY * this.player.getSpeed();\n                if (this.currentDimension === 'grass') {\n                    if (this.grassDimension.isValidMove(newX, newY)) {\n                        this.player.move(moveX, moveY);\n                    }\n                }\n                else {\n                    this.player.move(moveX, moveY);\n                }\n            }\n        }\n    };\n    Game.prototype.handleMouseDown = function (event) {\n        if (this.shop.isShopOpen()) {\n            var rect = this.canvas.getBoundingClientRect();\n            var x = event.clientX - rect.left;\n            var y = event.clientY - rect.top;\n            this.shop.handleClick(x, y, this.canvas.width, this.canvas.height);\n        }\n        else if (this.isEmoteWheelOpen && this.selectedEmote !== null) {\n            this.player.displayEmote(this.selectedEmote);\n            this.toggleEmoteWheel();\n        }\n        else if (this.isMouseControl) {\n            this.player.startDigging();\n        }\n    };\n    Game.prototype.handleMouseUp = function (event) {\n        if (this.isMouseControl) {\n            this.player.stopDigging();\n        }\n    };\n    Game.prototype.handleEmoteInput = function (event) {\n        switch (event.key) {\n            case '1':\n                this.player.displayEmote(player_1.Emote.Happy);\n                break;\n            case '2':\n                this.player.displayEmote(player_1.Emote.Sad);\n                break;\n            case '3':\n                this.player.displayEmote(player_1.Emote.Angry);\n                break;\n            case '4':\n                this.player.displayEmote(player_1.Emote.Surprised);\n                break;\n            case '5':\n                this.player.displayEmote(player_1.Emote.Love);\n                break;\n            case '6':\n                this.player.displayEmote(player_1.Emote.Cool);\n                break;\n            case '7':\n                this.player.displayEmote(player_1.Emote.Thinking);\n                break;\n            case '8':\n                this.player.displayEmote(player_1.Emote.Laughing);\n                break;\n            case '9':\n                this.player.displayEmote(player_1.Emote.Wink);\n                break;\n            case '0':\n                this.player.displayEmote(player_1.Emote.Confused);\n                break;\n            case 'q':\n                this.player.displayEmote(player_1.Emote.Sleepy);\n                break;\n            case 'w':\n                this.player.displayEmote(player_1.Emote.Excited);\n                break;\n            case 'e':\n                this.player.displayEmote(player_1.Emote.Nervous);\n                break;\n            case 'r':\n                this.player.displayEmote(player_1.Emote.Sick);\n                break;\n            case 't':\n                this.player.displayEmote(player_1.Emote.Rich);\n                break;\n            case 'y':\n                this.player.displayEmote(player_1.Emote.Strong);\n                break;\n            case 'u':\n                this.player.displayEmote(player_1.Emote.Scared);\n                break;\n            case 'i':\n                this.player.displayEmote(player_1.Emote.Crazy);\n                break;\n            case 'o':\n                this.player.displayEmote(player_1.Emote.Evil);\n                break;\n            case 'p':\n                this.player.displayEmote(player_1.Emote.Dead);\n                break;\n        }\n    };\n    Game.prototype.gameLoop = function () {\n        var _this = this;\n        var currentTime = Date.now();\n        var deltaTime = currentTime - this.lastUpdateTime;\n        this.lastUpdateTime = currentTime;\n        if (!this.isGameOver) {\n            this.update(deltaTime);\n        }\n        this.render();\n        requestAnimationFrame(function () { return _this.gameLoop(); });\n    };\n    Game.prototype.update = function (deltaTime) {\n        if (!this.isMouseControl) {\n            var dx = 0;\n            var dy = 0;\n            if (this.keysPressed.has('ArrowUp'))\n                dy -= 1;\n            if (this.keysPressed.has('ArrowDown'))\n                dy += 1;\n            if (this.keysPressed.has('ArrowLeft'))\n                dx -= 1;\n            if (this.keysPressed.has('ArrowRight'))\n                dx += 1;\n            if (dx !== 0 || dy !== 0) {\n                var speed = this.player.getSpeed();\n                var newX = this.player.getX() + dx * speed;\n                var newY = this.player.getY() + dy * speed;\n                if (this.currentDimension === 'grass') {\n                    if (this.grassDimension.isValidMove(newX, newY)) {\n                        this.player.move(dx * speed, dy * speed);\n                    }\n                }\n                else {\n                    this.player.move(dx * speed, dy * speed);\n                }\n            }\n        }\n        this.player.update(this.terrain, this.canvas.width, this.canvas.height, this.cameraX, this.cameraY);\n        console.log(\"Player position: (\".concat(this.player.getX(), \", \").concat(this.player.getY(), \"), Digging: \").concat(this.player.isDigging()));\n        if (Date.now() - this.lastHealthRecoveryTime > 500) {\n            this.player.recoverHealth(2);\n            this.lastHealthRecoveryTime = Date.now();\n        }\n        this.updateZoom();\n        var effectiveWidth = this.canvas.width / this.zoom;\n        var effectiveHeight = this.canvas.height / this.zoom;\n        this.cameraX = Math.max(0, Math.min(this.terrain.getWidth() - effectiveWidth, this.player.getX() - effectiveWidth / 2));\n        this.cameraY = Math.max(0, Math.min(this.terrain.getHeight() - effectiveHeight, this.player.getY() - effectiveHeight / 2));\n        if (this.currentDimension === 'grass') {\n            this.updateCloudMobs(deltaTime);\n            this.updateBumbleBees(deltaTime);\n        }\n        else if (this.currentDimension === 'alternate') {\n            this.alternateDimension.update(this.player, this.enemies, deltaTime);\n            this.updateEnemies(true); // Pass true to indicate alternate dimension\n        }\n        else {\n            if (this.player.isDigging()) {\n                this.player.dig(this.terrain);\n            }\n            this.updateEnemies(false); // Pass false to indicate normal dimension\n        }\n        this.player.updateEmote(deltaTime);\n        this.enemies.forEach(function (enemy) { return enemy.updateEmote(deltaTime); });\n        if (this.portalCooldown > 0) {\n            this.portalCooldown -= deltaTime;\n            if (this.portalCooldown < 0) {\n                this.portalCooldown = 0;\n            }\n        }\n        var portalLocation;\n        if (this.currentDimension === 'alternate') {\n            portalLocation = this.alternateDimension.getRegularPortalLocation();\n        }\n        else if (this.currentDimension === 'grass') {\n            portalLocation = this.grassDimension.getRegularPortalLocation();\n        }\n        else {\n            portalLocation = this.terrain.getPortalLocation();\n        }\n        var playerX = this.player.getX();\n        var playerY = this.player.getY();\n        var portalRadius = 25;\n        if (Math.abs(playerX - portalLocation.x) < portalRadius &&\n            Math.abs(playerY - portalLocation.y) < portalRadius &&\n            this.portalCooldown === 0) {\n            this.toggleDimension();\n            this.portalCooldown = this.PORTAL_COOLDOWN_DURATION;\n        }\n        if (this.currentDimension === 'alternate') {\n            this.alternateDimension.update(this.player, this.enemies, deltaTime);\n        }\n        else if (this.currentDimension === 'grass') {\n            this.grassDimension.update(this.player, this.cloudMobs, deltaTime);\n        }\n        else {\n            if (this.player.isDigging()) {\n                this.player.dig(this.terrain);\n            }\n        }\n        if (this.player.isDead()) {\n            this.soundManager.playHurtSound();\n            this.handlePlayerDeath();\n            return;\n        }\n    };\n    Game.prototype.updateZoom = function () {\n        var playerSize = this.player.getSize();\n        var minPlayerSize = 20;\n        var maxPlayerSize = 1000;\n        var zoomFactor = Math.log(playerSize / minPlayerSize) / Math.log(maxPlayerSize / minPlayerSize);\n        var newZoom = this.maxZoom * Math.pow(0.05, zoomFactor);\n        newZoom = Math.max(this.zoomCap, newZoom);\n        this.zoom = this.zoom * 0.9 + newZoom * 0.1;\n        this.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom));\n    };\n    Game.prototype.render = function () {\n        this.context.fillStyle = 'black';\n        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        this.context.save();\n        this.context.scale(this.zoom, this.zoom);\n        var centerX = this.canvas.width / (2 * this.zoom);\n        var centerY = this.canvas.height / (2 * this.zoom);\n        this.context.translate(centerX - this.player.getX(), centerY - this.player.getY());\n        var visibleWidth = this.canvas.width / this.zoom;\n        var visibleHeight = this.canvas.height / this.zoom;\n        var startX = Math.floor((this.player.getX() - visibleWidth / 2) / 10);\n        var startY = Math.floor((this.player.getY() - visibleHeight / 2) / 10);\n        var endX = Math.ceil((this.player.getX() + visibleWidth / 2) / 10);\n        var endY = Math.ceil((this.player.getY() + visibleHeight / 2) / 10);\n        if (this.currentDimension === 'grass') {\n            this.grassDimension.render(this.context, this.player, this.canvas.width, this.canvas.height, this.zoom);\n            this.renderCloudMobs();\n        }\n        else if (this.currentDimension === 'alternate') {\n            this.alternateDimension.render(this.context, this.player, this.canvas.width, this.canvas.height, this.zoom);\n            this.renderEnemies();\n        }\n        else {\n            this.terrain.generateTerrain(this.context, startX, startY, endX, endY);\n            this.renderEnemies();\n        }\n        this.player.draw(visibleWidth, visibleHeight);\n        this.context.restore();\n        if (this.shop.isShopOpen()) {\n            this.shop.render(this.canvas.width, this.canvas.height);\n        }\n        else if (this.isEmoteWheelOpen) {\n            this.renderEmoteWheel();\n        }\n        if (this.portalCooldown > 0) {\n            this.renderPortalCooldown();\n        }\n        if (this.isGameOver) {\n            this.renderGameOverMessage();\n        }\n        if (this.currentDimension !== 'normal') {\n            this.renderMinimap(this.context, 200, 200);\n        }\n    };\n    Game.prototype.renderEnemies = function () {\n        var _this = this;\n        this.enemies.forEach(function (enemy) {\n            if (_this.isEnemyVisible(enemy)) {\n                enemy.draw(_this.canvas.width / _this.zoom, _this.canvas.height / _this.zoom);\n            }\n        });\n    };\n    Game.prototype.isEnemyVisible = function (enemy) {\n        var enemyX = enemy.getX();\n        var enemyY = enemy.getY();\n        var playerX = this.player.getX();\n        var playerY = this.player.getY();\n        var visibleWidth = this.canvas.width / this.zoom;\n        var visibleHeight = this.canvas.height / this.zoom;\n        return (enemyX >= playerX - visibleWidth / 2 &&\n            enemyX <= playerX + visibleWidth / 2 &&\n            enemyY >= playerY - visibleHeight / 2 &&\n            enemyY <= playerY + visibleHeight / 2);\n    };\n    Game.prototype.spawnEnemies = function (count) {\n        for (var i = 0; i < count; i++) {\n            var x = Math.random() * this.terrain.getWidth();\n            var y = Math.random() * this.terrain.getHeight();\n            var enemy = new enemy_1.Enemy(x, y, this.terrain.getWidth(), this.terrain.getHeight(), this.context, this.player, this.terrain, this);\n            this.enemies.push(enemy);\n        }\n    };\n    Game.prototype.updateEnemies = function (isAlternateDimension) {\n        var _this = this;\n        this.enemies.forEach(function (enemy, index) {\n            enemy.update(_this.terrain, _this.canvas.width, _this.canvas.height, _this.cameraX, _this.cameraY);\n            var dx = _this.player.getX() - enemy.getX();\n            var dy = _this.player.getY() - enemy.getY();\n            var distance = Math.sqrt(dx * dx + dy * dy);\n            if (distance < (_this.player.getSize() + enemy.getSize()) / 2) {\n                var damage = Math.floor(enemy.getSize() * 0.5);\n                _this.player.takeDamage(damage);\n                _this.lastDamageSource = 'enemy';\n                console.log(\"Enemy dealt \".concat(damage, \" damage to player. Player health: \").concat(_this.player.getHealth()));\n                if (_this.player.getSize() > enemy.getSize()) {\n                    var scoreIncrease = Math.floor(enemy.getSize());\n                    _this.player.adjustScore(scoreIncrease);\n                    console.log(\"Player defeated enemy. Score increase: \".concat(scoreIncrease));\n                    _this.enemies.splice(index, 1);\n                }\n                else {\n                    var bounceDistance = 20;\n                    var bounceX = enemy.getX() + (dx / distance) * bounceDistance;\n                    var bounceY = enemy.getY() + (dy / distance) * bounceDistance;\n                    enemy.setPosition(bounceX, bounceY);\n                }\n            }\n            // Only allow digging in the normal dimension\n            if (!isAlternateDimension && enemy.isDigging()) {\n                enemy.dig(_this.terrain);\n            }\n        });\n        if (this.enemies.length < this.maxEnemies) {\n            var enemiesToSpawn = Math.min(5, this.maxEnemies - this.enemies.length);\n            this.spawnEnemies(enemiesToSpawn);\n        }\n    };\n    Game.prototype.toggleControls = function () {\n        this.isMouseControl = !this.isMouseControl;\n        if (this.isMouseControl) {\n            this.keysPressed.clear();\n        }\n        console.log(\"Mouse control is now \".concat(this.isMouseControl ? 'enabled' : 'disabled'));\n    };\n    Game.prototype.toggleEmoteWheel = function () {\n        this.isEmoteWheelOpen = !this.isEmoteWheelOpen;\n        if (!this.isEmoteWheelOpen) {\n            this.selectedEmote = null;\n        }\n    };\n    Game.prototype.getEmoteFromPosition = function (x, y) {\n        var centerX = this.canvas.width / 2;\n        var centerY = this.canvas.height / 2;\n        var dx = x - centerX;\n        var dy = y - centerY;\n        var distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance <= this.emoteWheelRadius) {\n            var angle = Math.atan2(dy, dx);\n            var index = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * Object.keys(player_1.Emote).length / 2);\n            return index;\n        }\n        return null;\n    };\n    Game.prototype.renderEmoteWheel = function () {\n        var centerX = this.canvas.width / 2;\n        var centerY = this.canvas.height / 2;\n        var emoteCount = Object.keys(player_1.Emote).length / 2;\n        var angleStep = (2 * Math.PI) / emoteCount;\n        this.context.save();\n        this.context.beginPath();\n        this.context.arc(centerX, centerY, this.emoteWheelRadius, 0, 2 * Math.PI);\n        this.context.fillStyle = 'rgba(0, 0, 0, 0.5)';\n        this.context.fill();\n        var ownedEmotes = this.player.getOwnedEmotes();\n        for (var i = 0; i < ownedEmotes.length; i++) {\n            var emote = ownedEmotes[i];\n            var angle = i * angleStep;\n            var x = centerX + Math.cos(angle) * this.emoteWheelRadius * 0.8;\n            var y = centerY + Math.sin(angle) * this.emoteWheelRadius * 0.8;\n            this.context.font = '20px Arial';\n            this.context.fillStyle = emote === this.selectedEmote ? 'yellow' : 'white';\n            this.context.textAlign = 'center';\n            this.context.textBaseline = 'middle';\n            this.context.fillText(this.getEmoteText(emote), x, y);\n        }\n        this.context.restore();\n    };\n    Game.prototype.getEmoteText = function (emote) {\n        switch (emote) {\n            case player_1.Emote.Happy: return '';\n            case player_1.Emote.Sad: return '';\n            case player_1.Emote.Angry: return '';\n            case player_1.Emote.Surprised: return '';\n            case player_1.Emote.Love: return '';\n            case player_1.Emote.Cool: return '';\n            case player_1.Emote.Thinking: return '';\n            case player_1.Emote.Laughing: return '';\n            case player_1.Emote.Wink: return '';\n            case player_1.Emote.Confused: return '';\n            case player_1.Emote.Sleepy: return '';\n            case player_1.Emote.Excited: return '';\n            case player_1.Emote.Nervous: return '';\n            case player_1.Emote.Sick: return '';\n            case player_1.Emote.Rich: return '';\n            case player_1.Emote.Strong: return '';\n            case player_1.Emote.Scared: return '';\n            case player_1.Emote.Crazy: return '';\n            case player_1.Emote.Evil: return '';\n            case player_1.Emote.Dead: return '';\n            default: return '';\n        }\n    };\n    Game.prototype.toggleDimension = function () {\n        if (this.portalCooldown === 0) {\n            this.soundManager.playPortalSound();\n            switch (this.currentDimension) {\n                case 'normal':\n                    this.currentDimension = 'alternate';\n                    this.player.setInAlternateDimension(true);\n                    var alternateDimensionPortal = this.alternateDimension.getRegularPortalLocation();\n                    this.player.setPosition(alternateDimensionPortal.x, alternateDimensionPortal.y);\n                    break;\n                case 'alternate':\n                    this.currentDimension = 'grass';\n                    this.player.setInAlternateDimension(true); // Still in an alternate dimension\n                    var grassDimensionPortal = this.grassDimension.getRegularPortalLocation();\n                    this.player.setPosition(grassDimensionPortal.x, grassDimensionPortal.y);\n                    break;\n                case 'grass':\n                    this.currentDimension = 'normal';\n                    this.player.setInAlternateDimension(false);\n                    var normalDimensionPortal = this.terrain.getPortalLocation();\n                    this.player.setPosition(normalDimensionPortal.x, normalDimensionPortal.y);\n                    break;\n            }\n            this.portalCooldown = this.PORTAL_COOLDOWN_DURATION;\n            this.updateCameraPosition();\n            this.updateMinimapVisibility();\n        }\n        else {\n            console.log(\"Portal on cooldown. Time remaining:\", this.portalCooldown / 1000, \"seconds\");\n        }\n    };\n    Game.prototype.updateCameraPosition = function () {\n        var effectiveWidth = this.canvas.width / this.zoom;\n        var effectiveHeight = this.canvas.height / this.zoom;\n        this.cameraX = Math.max(0, Math.min(this.terrain.getWidth() - effectiveWidth, this.player.getX() - effectiveWidth / 2));\n        this.cameraY = Math.max(0, Math.min(this.terrain.getHeight() - effectiveHeight, this.player.getY() - effectiveHeight / 2));\n    };\n    Game.prototype.renderPortalCooldown = function () {\n        var cooldownPercentage = this.portalCooldown / this.PORTAL_COOLDOWN_DURATION;\n        var barWidth = 200;\n        var barHeight = 20;\n        var x = (this.canvas.width - barWidth) / 2;\n        var y = 50;\n        this.context.fillStyle = 'rgba(0, 0, 0, 0.5)';\n        this.context.fillRect(x, y, barWidth, barHeight);\n        this.context.fillStyle = 'rgba(0, 100, 255, 0.7)';\n        this.context.fillRect(x, y, barWidth * (1 - cooldownPercentage), barHeight);\n        this.context.fillStyle = 'white';\n        this.context.font = '14px Arial';\n        this.context.textAlign = 'center';\n        this.context.textBaseline = 'middle';\n        this.context.fillText('Portal Cooldown', x + barWidth / 2, y + barHeight / 2);\n    };\n    Game.prototype.handlePlayerDeath = function () {\n        console.log(\"Player has died!\");\n        this.isGameOver = true;\n        var killedByMessage = \"an unknown cause\";\n        switch (this.lastDamageSource) {\n            case 'bee':\n                killedByMessage = \"a bumble bee\";\n                break;\n            case 'cloud':\n                killedByMessage = \"a cloud mob\";\n                break;\n            case 'enemy':\n                killedByMessage = \"an enemy\";\n                break;\n        }\n        this.gameOverMessage = \"Game Over! You have been killed by \".concat(killedByMessage, \".\");\n        this.render();\n        setTimeout(function () {\n            window.location.reload();\n        }, 3000); // Increased to 3 seconds to give more time to read the message\n    };\n    Game.prototype.renderGameOverMessage = function () {\n        var ctx = this.context;\n        ctx.save();\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        ctx.font = '48px Arial';\n        ctx.fillStyle = 'white';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(this.gameOverMessage, this.canvas.width / 2, this.canvas.height / 2);\n        ctx.font = '24px Arial';\n        ctx.fillText('Reloading...', this.canvas.width / 2, this.canvas.height / 2 + 50);\n        ctx.restore();\n    };\n    Game.prototype.renderMinimap = function (context, width, height) {\n        if (this.currentDimension === 'alternate' && this.alternateDimension) {\n            this.renderAlternateDimensionMinimap(context, width, height);\n        }\n        else if (this.currentDimension === 'grass' && this.grassDimension) {\n            this.renderGrassDimensionMinimap(context, width, height);\n        }\n    };\n    Game.prototype.renderAlternateDimensionMinimap = function (context, width, height) {\n        var scale = Math.min(width / this.alternateDimension.getWidth(), height / this.alternateDimension.getHeight());\n        context.fillStyle = '#000033'; // Dark blue background\n        context.fillRect(0, 0, width, height);\n        context.fillStyle = 'white'; // Walls\n        this.alternateDimension.getWalls().forEach(function (wall) {\n            context.fillRect(wall.x * scale, wall.y * scale, wall.width * scale, wall.height * scale);\n        });\n        var portal = this.alternateDimension.getRegularPortalLocation();\n        context.fillStyle = '#00BFFF'; // Light blue portal\n        context.beginPath();\n        context.arc(portal.x * scale, portal.y * scale, 5, 0, Math.PI * 2);\n        context.fill();\n        context.fillStyle = 'red'; // Player\n        context.beginPath();\n        context.arc(this.player.getX() * scale, this.player.getY() * scale, 3, 0, Math.PI * 2);\n        context.fill();\n    };\n    Game.prototype.renderGrassDimensionMinimap = function (context, width, height) {\n        var scale = Math.min(width / this.grassDimension.getWidth(), height / this.grassDimension.getHeight());\n        context.fillStyle = '#87CEEB'; // Sky blue background (water)\n        context.fillRect(0, 0, width, height);\n        context.fillStyle = '#228B22'; // Forest green for islands\n        this.grassDimension.getIslands().forEach(function (island) {\n            context.beginPath();\n            context.arc(island.x * scale, island.y * scale, island.radius * scale, 0, Math.PI * 2);\n            context.fill();\n        });\n        // Draw bridges on minimap\n        context.strokeStyle = '#8B4513'; // Saddle Brown for bridges\n        this.grassDimension.getBridges().forEach(function (bridge) {\n            context.beginPath();\n            context.moveTo(bridge.start.x * scale, bridge.start.y * scale);\n            context.lineTo(bridge.end.x * scale, bridge.end.y * scale);\n            context.lineWidth = bridge.width * scale;\n            context.stroke();\n        });\n        var regularPortal = this.grassDimension.getRegularPortalLocation();\n        var grassPortal = this.grassDimension.getGrassPortalLocation();\n        context.fillStyle = '#00BFFF'; // Light blue for portals\n        context.beginPath();\n        context.arc(regularPortal.x * scale, regularPortal.y * scale, 5, 0, Math.PI * 2);\n        context.fill();\n        context.beginPath();\n        context.arc(grassPortal.x * scale, grassPortal.y * scale, 5, 0, Math.PI * 2);\n        context.fill();\n        context.fillStyle = 'red'; // Player\n        context.beginPath();\n        context.arc(this.player.getX() * scale, this.player.getY() * scale, 3, 0, Math.PI * 2);\n        context.fill();\n    };\n    Game.prototype.updateMinimapVisibility = function () {\n        var minimapCanvas = document.querySelector('canvas:not(#gameCanvas)');\n        if (minimapCanvas) {\n            minimapCanvas.style.display = this.currentDimension !== 'normal' ? 'block' : 'none';\n        }\n    };\n    Game.prototype.distanceBetween = function (x1, y1, x2, y2) {\n        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    };\n    Game.prototype.updateCloudMobs = function (deltaTime) {\n        var _this = this;\n        this.cloudMobs.forEach(function (cloudMob, index) {\n            cloudMob.update(deltaTime);\n            var dx = _this.player.getX() - cloudMob.getX();\n            var dy = _this.player.getY() - cloudMob.getY();\n            var distance = Math.sqrt(dx * dx + dy * dy);\n            if (distance < (_this.player.getSize() + cloudMob.getSize()) / 2) {\n                // Collision detected\n                var damage = Math.floor(_this.player.getSize() * 0.1); // Player deals 10% of its size as damage\n                cloudMob.takeDamage(damage);\n                cloudMob.bounceOff(_this.player.getX(), _this.player.getY());\n                if (cloudMob.isDead()) {\n                    var scoreIncrease = Math.floor(cloudMob.getSize());\n                    _this.player.adjustScore(scoreIncrease);\n                    console.log(\"Player destroyed cloud. Score increase: \".concat(scoreIncrease));\n                    _this.cloudMobs.splice(index, 1);\n                }\n                else {\n                    _this.player.takeDamage(10); // Cloud deals 10 damage to player\n                    _this.lastDamageSource = 'cloud';\n                    console.log(\"Cloud dealt 10 damage to player. Player health: \".concat(_this.player.getHealth()));\n                }\n            }\n        });\n        if (this.cloudMobs.length < this.maxCloudMobs) {\n            var cloudsToSpawn = Math.min(2, this.maxCloudMobs - this.cloudMobs.length);\n            this.spawnCloudMobs(cloudsToSpawn);\n        }\n    };\n    Game.prototype.spawnCloudMobs = function (count) {\n        for (var i = 0; i < count; i++) {\n            var x = Math.random() * this.terrain.getWidth();\n            var y = Math.random() * this.terrain.getHeight();\n            var size = Math.random() * 30 + 20; // Cloud size between 20 and 50\n            var health = size * 10; // Health proportional to size\n            var cloudMob = new cloudMob_1.CloudMob(x, y, size, health, this.context, this.player, this.terrain);\n            this.cloudMobs.push(cloudMob);\n        }\n    };\n    Game.prototype.renderCloudMobs = function () {\n        var _this = this;\n        this.cloudMobs.forEach(function (cloudMob) {\n            if (_this.isCloudMobVisible(cloudMob)) {\n                cloudMob.draw();\n            }\n        });\n    };\n    Game.prototype.isCloudMobVisible = function (cloudMob) {\n        var cloudMobX = cloudMob.getX();\n        var cloudMobY = cloudMob.getY();\n        var playerX = this.player.getX();\n        var playerY = this.player.getY();\n        var visibleWidth = this.canvas.width / this.zoom;\n        var visibleHeight = this.canvas.height / this.zoom;\n        return (cloudMobX >= playerX - visibleWidth / 2 &&\n            cloudMobX <= playerX + visibleWidth / 2 &&\n            cloudMobY >= playerY - visibleHeight / 2 &&\n            cloudMobY <= playerY + visibleHeight / 2);\n    };\n    Game.prototype.updateBumbleBees = function (deltaTime) {\n        var _this = this;\n        var bees = this.grassDimension.getBumbleBees();\n        bees.forEach(function (bee) {\n            bee.update(deltaTime);\n            var dx = _this.player.getX() - bee.getX();\n            var dy = _this.player.getY() - bee.getY();\n            var distance = Math.sqrt(dx * dx + dy * dy);\n            if (distance < (_this.player.getSize() + bee.getSize()) / 2) {\n                if (bee.isAngered()) {\n                    var damage = Math.floor(_this.player.getMaxHealth() * 0.75);\n                    _this.player.takeDamage(damage);\n                    _this.lastDamageSource = 'bee';\n                    console.log(\"Bee dealt \".concat(damage, \" damage to player. Player health: \").concat(_this.player.getHealth()));\n                }\n                else {\n                    bee.anger();\n                    _this.soundManager.playAngryBeeSound(); // Play the angry bee sound\n                }\n            }\n        });\n        // Filter out dead bees and stop their buzzing\n        var aliveBees = bees.filter(function (bee) {\n            if (bee.isDead()) {\n                bee.stopBuzzing();\n                return false;\n            }\n            return true;\n        });\n        // Update the bees array in the grass dimension\n        this.grassDimension.setBumbleBees(aliveBees);\n    };\n    // Add a new method to handle item collection\n    Game.prototype.collectItem = function (itemType) {\n        this.soundManager.playCollectSound();\n        // Add any other item collection logic here\n    };\n    Game.prototype.getSoundManager = function () {\n        return this.soundManager;\n    };\n    Game.prototype.createVolumeSlider = function () {\n        var _this = this;\n        var slider = document.createElement('input');\n        slider.type = 'range';\n        slider.min = '0';\n        slider.max = '1';\n        slider.step = '0.1';\n        slider.value = this.soundManager.getVolume().toString();\n        slider.style.position = 'absolute';\n        slider.style.top = '10px';\n        slider.style.right = '10px';\n        slider.style.width = '100px';\n        slider.style.zIndex = '1000';\n        slider.addEventListener('input', function () {\n            var volume = parseFloat(slider.value);\n            _this.soundManager.setVolume(volume);\n        });\n        document.body.appendChild(slider);\n        return slider;\n    };\n    Game.prototype.createMuteButton = function () {\n        var _this = this;\n        var button = document.createElement('button');\n        button.textContent = ''; // Unicode speaker icon\n        button.style.position = 'absolute';\n        button.style.top = '10px';\n        button.style.right = '120px'; // Position it next to the volume slider\n        button.style.zIndex = '1000';\n        button.style.fontSize = '24px';\n        button.style.padding = '5px 10px';\n        button.style.backgroundColor = 'transparent';\n        button.style.border = 'none';\n        button.style.color = 'white';\n        button.style.cursor = 'pointer';\n        button.addEventListener('click', function () { return _this.toggleMute(); });\n        document.body.appendChild(button);\n        return button;\n    };\n    Game.prototype.toggleMute = function () {\n        this.isMuted = !this.isMuted;\n        this.soundManager.setMute(this.isMuted);\n        this.muteButton.textContent = this.isMuted ? '' : '';\n        if (this.isMuted) {\n            this.volumeSlider.disabled = true;\n        }\n        else {\n            this.volumeSlider.disabled = false;\n        }\n        localStorage.setItem('isMuted', this.isMuted.toString());\n    };\n    Game.prototype.loadSettings = function () {\n        var muteSetting = localStorage.getItem('isMuted');\n        this.isMuted = muteSetting === 'true';\n    };\n    Game.prototype.applySettings = function () {\n        this.soundManager.setMute(this.isMuted);\n        this.muteButton.textContent = this.isMuted ? '' : '';\n        this.volumeSlider.disabled = this.isMuted;\n    };\n    return Game;\n}());\nexports.Game = Game;\n\n\n//# sourceURL=webpack:///./src/game.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar game_1 = __webpack_require__(/*! ./game */ \"./src/game.ts\");\nvar titleScreen_1 = __webpack_require__(/*! ./titleScreen */ \"./src/titleScreen.ts\");\nvar GameManager = /** @class */ (function () {\n    function GameManager() {\n        var _this = this;\n        this.game = null;\n        this.isFullscreen = false;\n        this.canvas = document.getElementById('gameCanvas');\n        this.context = this.canvas.getContext('2d');\n        this.volumeSlider = this.createVolumeSlider();\n        this.muteButton = this.createMuteButton();\n        this.titleScreen = new titleScreen_1.TitleScreen(this.canvas, this.context, function () { return _this.startGame(); }, this.volumeSlider, this.muteButton);\n        this.controlToggleButton = document.createElement('button');\n        this.controlToggleButton.textContent = 'Toggle Controls';\n        this.controlToggleButton.style.position = 'absolute';\n        this.controlToggleButton.style.top = '50px';\n        this.controlToggleButton.style.right = '10px';\n        this.controlToggleButton.style.zIndex = '1000';\n        document.body.appendChild(this.controlToggleButton);\n        // Create minimap canvas\n        this.minimapCanvas = document.createElement('canvas');\n        this.minimapCanvas.width = 200;\n        this.minimapCanvas.height = 200;\n        this.minimapCanvas.style.position = 'absolute';\n        this.minimapCanvas.style.top = '100px';\n        this.minimapCanvas.style.right = '10px';\n        this.minimapCanvas.style.zIndex = '1000';\n        this.minimapCanvas.style.border = '1px solid white';\n        this.minimapCanvas.style.display = 'none'; // Initially hide the minimap\n        document.body.appendChild(this.minimapCanvas);\n        this.minimapContext = this.minimapCanvas.getContext('2d');\n        this.loadSettings();\n        this.applySettings();\n    }\n    GameManager.prototype.createVolumeSlider = function () {\n        var slider = document.createElement('input');\n        slider.type = 'range';\n        slider.min = '0';\n        slider.max = '1';\n        slider.step = '0.1';\n        slider.value = '0.5'; // Default volume\n        slider.style.position = 'absolute';\n        slider.style.top = '10px';\n        slider.style.right = '10px';\n        slider.style.width = '100px';\n        slider.style.zIndex = '1000';\n        document.body.appendChild(slider);\n        return slider;\n    };\n    GameManager.prototype.createMuteButton = function () {\n        var button = document.createElement('button');\n        button.textContent = ''; // Unicode speaker icon\n        button.style.position = 'absolute';\n        button.style.top = '10px';\n        button.style.right = '120px'; // Position it next to the volume slider\n        button.style.zIndex = '1000';\n        button.style.fontSize = '24px';\n        button.style.padding = '5px 10px';\n        button.style.backgroundColor = 'transparent';\n        button.style.border = 'none';\n        button.style.color = 'white';\n        button.style.cursor = 'pointer';\n        document.body.appendChild(button);\n        return button;\n    };\n    GameManager.prototype.loadSettings = function () {\n        var fullscreenSetting = localStorage.getItem('isFullscreen');\n        this.isFullscreen = fullscreenSetting === 'true';\n    };\n    GameManager.prototype.applySettings = function () {\n        if (this.isFullscreen) {\n            this.enterFullscreen();\n        }\n    };\n    GameManager.prototype.init = function () {\n        var _this = this;\n        this.resizeCanvas();\n        window.addEventListener('resize', function () { return _this.resizeCanvas(); });\n        this.showTitleScreen();\n    };\n    GameManager.prototype.resizeCanvas = function () {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n        if (this.game) {\n            this.game.resizeCanvas();\n        }\n    };\n    GameManager.prototype.showTitleScreen = function () {\n        this.titleScreen.show();\n        this.controlToggleButton.style.display = 'none';\n        this.minimapCanvas.style.display = 'none';\n    };\n    GameManager.prototype.startGame = function () {\n        this.game = new game_1.Game('gameCanvas', this.titleScreen);\n        this.setupFullscreenButton();\n        this.setupControlToggleButton();\n        this.controlToggleButton.style.display = 'block';\n        // Remove this line: this.minimapCanvas.style.display = 'block';\n        this.updateMinimap();\n    };\n    GameManager.prototype.setupFullscreenButton = function () {\n        var _this = this;\n        var fullscreenButton = document.getElementById('fullscreenButton');\n        fullscreenButton.addEventListener('click', function () { return _this.toggleFullscreen(); });\n    };\n    GameManager.prototype.setupControlToggleButton = function () {\n        var _this = this;\n        this.controlToggleButton.addEventListener('click', function () {\n            if (_this.game) {\n                _this.game.toggleControls();\n            }\n        });\n    };\n    GameManager.prototype.toggleFullscreen = function () {\n        if (!document.fullscreenElement) {\n            this.enterFullscreen();\n        }\n        else {\n            this.exitFullscreen();\n        }\n    };\n    GameManager.prototype.enterFullscreen = function () {\n        document.documentElement.requestFullscreen();\n        this.isFullscreen = true;\n        localStorage.setItem('isFullscreen', 'true');\n    };\n    GameManager.prototype.exitFullscreen = function () {\n        if (document.exitFullscreen) {\n            document.exitFullscreen();\n        }\n        this.isFullscreen = false;\n        localStorage.setItem('isFullscreen', 'false');\n    };\n    GameManager.prototype.updateMinimap = function () {\n        var _this = this;\n        if (this.game) {\n            this.game.renderMinimap(this.minimapContext, this.minimapCanvas.width, this.minimapCanvas.height);\n        }\n        requestAnimationFrame(function () { return _this.updateMinimap(); });\n    };\n    return GameManager;\n}());\nwindow.onload = function () {\n    var gameManager = new GameManager();\n    gameManager.init();\n};\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/player.ts":
/*!***********************!*\
  !*** ./src/player.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Player = exports.Emote = void 0;\nvar Emote;\n(function (Emote) {\n    Emote[Emote[\"Happy\"] = 0] = \"Happy\";\n    Emote[Emote[\"Sad\"] = 1] = \"Sad\";\n    Emote[Emote[\"Angry\"] = 2] = \"Angry\";\n    Emote[Emote[\"Surprised\"] = 3] = \"Surprised\";\n    Emote[Emote[\"Love\"] = 4] = \"Love\";\n    Emote[Emote[\"Cool\"] = 5] = \"Cool\";\n    Emote[Emote[\"Thinking\"] = 6] = \"Thinking\";\n    Emote[Emote[\"Laughing\"] = 7] = \"Laughing\";\n    Emote[Emote[\"Wink\"] = 8] = \"Wink\";\n    Emote[Emote[\"Confused\"] = 9] = \"Confused\";\n    Emote[Emote[\"Sleepy\"] = 10] = \"Sleepy\";\n    Emote[Emote[\"Excited\"] = 11] = \"Excited\";\n    Emote[Emote[\"Nervous\"] = 12] = \"Nervous\";\n    Emote[Emote[\"Sick\"] = 13] = \"Sick\";\n    Emote[Emote[\"Rich\"] = 14] = \"Rich\";\n    Emote[Emote[\"Strong\"] = 15] = \"Strong\";\n    Emote[Emote[\"Scared\"] = 16] = \"Scared\";\n    Emote[Emote[\"Crazy\"] = 17] = \"Crazy\";\n    Emote[Emote[\"Evil\"] = 18] = \"Evil\";\n    Emote[Emote[\"Dead\"] = 19] = \"Dead\";\n})(Emote || (exports.Emote = Emote = {}));\nvar Player = /** @class */ (function () {\n    function Player(x, y, health, attack, context, terrain, game) {\n        this.movementDirection = { x: 0, y: 0 };\n        this.baseSpeed = 4;\n        this.minSpeed = 0.3;\n        this.maxSpeed = 5;\n        this.optimalSize = 40;\n        this.ringRotation = 0;\n        this.score = 0;\n        this._isDigging = false;\n        this.maxSize = 1000;\n        this.goldScore = 0;\n        this.level = 1;\n        this.xp = 0;\n        this.xpToNextLevel = 100;\n        this.currentEmote = null;\n        this.emoteDisplayTime = 0;\n        this.EMOTE_DURATION = 2000;\n        this.ownedEmotes = new Set([Emote.Happy, Emote.Sad, Emote.Angry, Emote.Surprised]);\n        this.isInAlternateDimension = false;\n        this.alternateDimensionScore = 0;\n        this.alternateDimensionSize = 30; // Increased from 20 to 30\n        this.alternateDimensionSpeedMultiplier = 0.5; // 50% slower in alternate dimension\n        this.x = x;\n        this.y = y;\n        this.size = 20;\n        this.health = health;\n        this.shield = 0;\n        this.context = context;\n        this.terrain = terrain;\n        this.game = game;\n        this.loadGoldScore();\n        this.loadOwnedEmotes();\n        this.calculateLevelAndXP();\n        this.normalSize = this.size;\n        this.maxHealth = 100; // or whatever the max health should be\n    }\n    Player.prototype.move = function (dx, dy) {\n        var speed = this.getSpeed();\n        var newX = this.x + dx * speed;\n        var newY = this.y + dy * speed;\n        if (newX >= 0 && newX < this.terrain.getWidth() && newY >= 0 && newY < this.terrain.getHeight()) {\n            this.x = newX;\n            this.y = newY;\n            var length_1 = Math.sqrt(dx * dx + dy * dy);\n            if (length_1 > 0) {\n                this.movementDirection = { x: dx / length_1, y: dy / length_1 };\n            }\n            this.dig(this.terrain);\n        }\n    };\n    Player.prototype.getSpeed = function () {\n        var minSize = 20;\n        var normalizedSize = Math.min((this.size - minSize) / (this.maxSize - minSize), 1);\n        var speedDecrease = normalizedSize * 0.95;\n        var baseSpeed = Math.max(this.minSpeed, this.baseSpeed - this.baseSpeed * speedDecrease);\n        baseSpeed *= (1 + (this.level - 1) * 0.05);\n        // Apply speed reduction in alternate dimension\n        if (this.isInAlternateDimension) {\n            baseSpeed *= this.alternateDimensionSpeedMultiplier;\n        }\n        return baseSpeed;\n    };\n    Player.prototype.dig = function (terrain) {\n        if (this.isInAlternateDimension) {\n            return []; // Return an empty array if in alternate dimension\n        }\n        var digRadius = Math.floor(this.size / 2);\n        var dugBlocks = [];\n        for (var dx = -digRadius; dx <= digRadius; dx++) {\n            for (var dy = -digRadius; dy <= digRadius; dy++) {\n                if (dx * dx + dy * dy <= digRadius * digRadius) {\n                    var block = terrain.removeBlock(this.x + dx, this.y + dy);\n                    if (block) {\n                        dugBlocks.push(block);\n                        if (block.type === 'gold_ore' && !this.isInAlternateDimension) {\n                            this.game.getSoundManager().playGoldDigSound();\n                        }\n                    }\n                }\n            }\n        }\n        for (var _i = 0, dugBlocks_1 = dugBlocks; _i < dugBlocks_1.length; _i++) {\n            var block = dugBlocks_1[_i];\n            this.handleDugBlock(block);\n        }\n        return dugBlocks;\n    };\n    Player.prototype.handleDugBlock = function (block) {\n        switch (block.type) {\n            case 'uranium':\n                this.adjustHealth(-5);\n                break;\n            case 'lava':\n                this.adjustHealth(-20); // This will now stop draining at 5 health\n                break;\n            case 'quartz':\n                this.adjustShield(10);\n                break;\n            case 'bedrock':\n                this.adjustScore(5);\n                break;\n            case 'gold_ore':\n                this.adjustGoldScore(1);\n                break;\n            default:\n                this.adjustScore(1);\n        }\n        this.setSize(this.getScore() + this.getGoldScore());\n    };\n    Player.prototype.draw = function (screenWidth, screenHeight) {\n        this.context.save();\n        this.context.setTransform(1, 0, 0, 1, 0, 0);\n        this.context.fillStyle = 'white';\n        this.context.font = '24px Arial';\n        this.context.textAlign = 'left';\n        this.context.textBaseline = 'top';\n        this.context.fillText(\"Level: \".concat(this.level), 10, 10);\n        this.context.restore();\n        this.updateRingRotation();\n        this.ringRotation += Math.PI / 180;\n        if (this.ringRotation >= Math.PI * 2) {\n            this.ringRotation -= Math.PI * 2;\n        }\n        this.context.strokeStyle = 'black';\n        this.context.fillStyle = 'black';\n        this.context.lineWidth = 5;\n        var ringRadius = this.size / 2 + this.size / 6;\n        var curveCount = 8;\n        var curveAngle = (Math.PI * 2) / curveCount;\n        var curveDepth = this.size / 4;\n        this.context.beginPath();\n        for (var i = 0; i < curveCount; i++) {\n            var startAngle = i * curveAngle + this.ringRotation;\n            var endAngle = (i + 1) * curveAngle + this.ringRotation;\n            var midAngle = (startAngle + endAngle) / 2;\n            var startX = this.x + Math.cos(startAngle) * ringRadius;\n            var startY = this.y + Math.sin(startAngle) * ringRadius;\n            var endX = this.x + Math.cos(endAngle) * ringRadius;\n            var endY = this.y + Math.sin(endAngle) * ringRadius;\n            var controlX = this.x + Math.cos(midAngle) * (ringRadius - curveDepth);\n            var controlY = this.y + Math.sin(midAngle) * (ringRadius - curveDepth);\n            if (i === 0) {\n                this.context.moveTo(startX, startY);\n            }\n            this.context.quadraticCurveTo(controlX, controlY, endX, endY);\n        }\n        this.context.closePath();\n        this.context.fill();\n        this.context.stroke();\n        this.context.fillStyle = 'gray';\n        this.context.beginPath();\n        this.context.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);\n        this.context.fill();\n        var eyeWidth = this.size / 6;\n        var eyeHeight = this.size / 4;\n        var eyeY = this.y - eyeHeight / 2;\n        this.context.fillStyle = 'white';\n        this.context.fillRect(this.x - this.size / 6 - eyeWidth / 2, eyeY, eyeWidth, eyeHeight);\n        this.context.fillRect(this.x + this.size / 6 - eyeWidth / 2, eyeY, eyeWidth, eyeHeight);\n        this.context.fillStyle = 'black';\n        var pupilWidth = eyeWidth * 0.6;\n        var pupilHeight = eyeHeight * 0.6;\n        var maxPupilOffset = (eyeWidth - pupilWidth) / 2;\n        var pupilOffsetX = this.movementDirection.x * maxPupilOffset;\n        var pupilOffsetY = this.movementDirection.y * maxPupilOffset;\n        this.context.fillRect(this.x - this.size / 6 - pupilWidth / 2 + pupilOffsetX, eyeY + (eyeHeight - pupilHeight) / 2 + pupilOffsetY, pupilWidth, pupilHeight);\n        this.context.fillRect(this.x + this.size / 6 - pupilWidth / 2 + pupilOffsetX, eyeY + (eyeHeight - pupilHeight) / 2 + pupilOffsetY, pupilWidth, pupilHeight);\n        this.context.strokeStyle = 'black';\n        this.context.lineWidth = 2;\n        this.context.beginPath();\n        this.context.arc(this.x, this.y + this.size / 8, this.size / 5, 0.2 * Math.PI, 0.8 * Math.PI);\n        this.context.stroke();\n        var barWidth = this.size * 2;\n        var barHeight = 5;\n        var healthPercentage = this.health / 100;\n        var shieldPercentage = this.shield / 100;\n        this.context.fillStyle = 'red';\n        this.context.fillRect(this.x - barWidth / 2, this.y - this.size / 2 - 10, barWidth, barHeight);\n        this.context.fillStyle = 'green';\n        this.context.fillRect(this.x - barWidth / 2, this.y - this.size / 2 - 10, barWidth * healthPercentage, barHeight);\n        this.context.fillStyle = 'blue';\n        this.context.fillRect(this.x - barWidth / 2 + barWidth * healthPercentage, this.y - this.size / 2 - 10, barWidth * shieldPercentage, barHeight);\n        this.context.font = \"\".concat(this.size / 3, \"px Arial\");\n        this.context.textAlign = 'center';\n        // Display the combined score (regular + alternate dimension)\n        this.context.fillStyle = 'white';\n        this.context.fillText(\"\".concat(this.getScore()), this.x, this.y - this.size / 2 - 20);\n        this.context.fillStyle = 'gold';\n        this.context.fillText(\"\".concat(this.goldScore), this.x + this.size / 2, this.y - this.size / 2 - 20);\n        var xpPercentage = this.xp / this.xpToNextLevel;\n        this.context.fillStyle = 'rgba(0, 0, 0, 0.5)';\n        this.context.fillRect(this.x - barWidth / 2, this.y - this.size / 2 - 25, barWidth, barHeight);\n        this.context.fillStyle = 'yellow';\n        this.context.fillRect(this.x - barWidth / 2, this.y - this.size / 2 - 25, barWidth * xpPercentage, barHeight);\n        if (this.currentEmote !== null) {\n            this.drawEmote();\n        }\n    };\n    Player.prototype.getX = function () { return this.x; };\n    Player.prototype.getY = function () { return this.y; };\n    Player.prototype.getHealth = function () { return this.health; };\n    Player.prototype.getShield = function () { return this.shield; };\n    Player.prototype.adjustHealth = function (amount) {\n        if (amount < 0) {\n            // For damage (negative amount)\n            if (this.health > 5) {\n                // Only apply damage if health is above 5\n                this.health = Math.max(5, this.health + amount);\n            }\n        }\n        else {\n            // For healing (positive amount)\n            this.health = Math.min(100, this.health + amount);\n        }\n    };\n    Player.prototype.takeDamage = function (amount) {\n        if (this.shield > 0) {\n            if (this.shield >= amount) {\n                this.shield -= amount;\n                amount = 0;\n            }\n            else {\n                amount -= this.shield;\n                this.shield = 0;\n            }\n        }\n        if (amount > 0) {\n            this.health = Math.max(0, this.health - amount);\n        }\n        console.log(\"Player took \".concat(amount, \" damage. Health: \").concat(this.health, \", Shield: \").concat(this.shield));\n    };\n    Player.prototype.adjustShield = function (amount) {\n        this.shield = Math.max(0, Math.min(100, this.shield + amount));\n    };\n    Player.prototype.recoverHealth = function (amount) {\n        this.health = Math.min(100, this.health + amount);\n    };\n    Player.prototype.setSize = function (score) {\n        if (!this.isInAlternateDimension) {\n            var minSize = 20;\n            var growthFactor = 1.5;\n            var levelBonus = (this.level - 1) * 0.1;\n            var newSize = (minSize + Math.sqrt(score) * growthFactor) * (1 + levelBonus);\n            this.size = Math.max(minSize, Math.min(this.maxSize, newSize));\n            this.normalSize = this.size;\n        }\n    };\n    Player.prototype.getSize = function () {\n        return this.isInAlternateDimension ? this.alternateDimensionSize : this.size;\n    };\n    Player.prototype.getContext = function () {\n        return this.context;\n    };\n    Player.prototype.updateRingRotation = function () {\n        this.ringRotation += Math.PI / 180;\n        if (this.ringRotation >= Math.PI * 2) {\n            this.ringRotation -= Math.PI * 2;\n        }\n    };\n    Player.prototype.getScore = function () {\n        return this.score;\n    };\n    Player.prototype.adjustScore = function (amount) {\n        this.score += amount;\n        this.setSize(this.score);\n        console.log(\"Score adjusted. New score: \".concat(this.score));\n    };\n    Player.prototype.startDigging = function () {\n        this._isDigging = true;\n        console.log('Player started digging');\n    };\n    Player.prototype.stopDigging = function () {\n        this._isDigging = false;\n        console.log('Player stopped digging');\n    };\n    Player.prototype.isDigging = function () {\n        return this._isDigging;\n    };\n    Player.prototype.update = function (terrain, screenWidth, screenHeight, cameraX, cameraY) {\n        if (this._isDigging) {\n            this.dig(terrain);\n        }\n    };\n    Player.prototype.getGoldScore = function () {\n        return this.goldScore;\n    };\n    Player.prototype.adjustGoldScore = function (amount) {\n        this.goldScore += amount;\n        this.saveGoldScore();\n        this.calculateLevelAndXP();\n        console.log(\"Gold score adjusted. New gold score: \".concat(this.goldScore));\n    };\n    Player.prototype.saveGoldScore = function () {\n        localStorage.setItem('playerGoldScore', this.goldScore.toString());\n    };\n    Player.prototype.loadGoldScore = function () {\n        var savedGoldScore = localStorage.getItem('playerGoldScore');\n        if (savedGoldScore !== null) {\n            this.goldScore = parseInt(savedGoldScore, 10);\n        }\n    };\n    Player.prototype.calculateLevelAndXP = function () {\n        var oldLevel = this.level;\n        this.level = Math.floor(Math.sqrt(this.goldScore / 100)) + 1;\n        this.xp = this.goldScore % 100;\n        this.xpToNextLevel = 100;\n        if (this.level > oldLevel) {\n            console.log(\"Level up! New level: \".concat(this.level));\n            this.onLevelUp();\n        }\n    };\n    Player.prototype.onLevelUp = function () {\n        var maxHealth = 100 + (this.level - 1) * 10;\n        var maxShield = 100 + (this.level - 1) * 5;\n        this.health = Math.min(this.health, maxHealth);\n        this.shield = Math.min(this.shield, maxShield);\n        this.baseSpeed = 4 + (this.level - 1) * 0.1;\n    };\n    Player.prototype.getLevel = function () {\n        return this.level;\n    };\n    Player.prototype.getXP = function () {\n        return this.xp;\n    };\n    Player.prototype.getXPToNextLevel = function () {\n        return this.xpToNextLevel;\n    };\n    Player.prototype.displayEmote = function (emote) {\n        if (this.ownedEmotes.has(emote)) {\n            this.currentEmote = emote;\n            this.emoteDisplayTime = this.EMOTE_DURATION;\n        }\n    };\n    Player.prototype.updateEmote = function (deltaTime) {\n        if (this.emoteDisplayTime > 0) {\n            this.emoteDisplayTime -= deltaTime;\n            if (this.emoteDisplayTime <= 0) {\n                this.currentEmote = null;\n            }\n        }\n    };\n    Player.prototype.drawEmote = function () {\n        if (this.currentEmote !== null) {\n            var emoteSize = this.size * 1.5;\n            var emoteX = this.x;\n            var emoteY = this.y - this.size * 1.5;\n            this.context.save();\n            this.context.setTransform(1, 0, 0, 1, 0, 0);\n            this.context.fillStyle = 'white';\n            this.context.font = \"\".concat(emoteSize, \"px Arial\");\n            this.context.textAlign = 'center';\n            this.context.textBaseline = 'middle';\n            var emoteText = this.getEmoteText(this.currentEmote);\n            this.context.fillText(emoteText, emoteX, emoteY);\n            this.context.restore();\n        }\n    };\n    Player.prototype.getEmoteText = function (emote) {\n        switch (emote) {\n            case Emote.Happy:\n                return ':)';\n            case Emote.Sad:\n                return ':(';\n            case Emote.Angry:\n                return '>:(';\n            case Emote.Surprised:\n                return ':O';\n            case Emote.Love:\n                return '<3';\n            case Emote.Cool:\n                return 'B)';\n            case Emote.Thinking:\n                return 'O.o';\n            case Emote.Laughing:\n                return ':D';\n            case Emote.Wink:\n                return ';)';\n            case Emote.Confused:\n                return ':/';\n            case Emote.Sleepy:\n                return ':Z';\n            case Emote.Excited:\n                return ':P';\n            case Emote.Nervous:\n                return ':|';\n            case Emote.Sick:\n                return ':X';\n            case Emote.Rich:\n                return ':$';\n            case Emote.Strong:\n                return ':@';\n            case Emote.Scared:\n                return ':!';\n            case Emote.Crazy:\n                return ':#';\n            case Emote.Evil:\n                return '>:)';\n            case Emote.Dead:\n                return 'x_x';\n            default:\n                return '';\n        }\n    };\n    Player.prototype.hasEmote = function (emote) {\n        return this.ownedEmotes.has(emote);\n    };\n    Player.prototype.getOwnedEmotes = function () {\n        return Array.from(this.ownedEmotes);\n    };\n    Player.prototype.buyEmote = function (emote) {\n        if (this.goldScore >= 300 && !this.ownedEmotes.has(emote)) {\n            this.goldScore -= 300;\n            this.ownedEmotes.add(emote);\n            this.saveGoldScore();\n            this.saveOwnedEmotes();\n            this.game.getSoundManager().playBuyEmoteSound();\n            return true;\n        }\n        return false;\n    };\n    Player.prototype.saveOwnedEmotes = function () {\n        var ownedEmotesArray = Array.from(this.ownedEmotes);\n        localStorage.setItem('playerOwnedEmotes', JSON.stringify(ownedEmotesArray));\n    };\n    Player.prototype.loadOwnedEmotes = function () {\n        var savedEmotes = localStorage.getItem('playerOwnedEmotes');\n        if (savedEmotes) {\n            var emoteArray = JSON.parse(savedEmotes);\n            this.ownedEmotes = new Set(emoteArray);\n        }\n        else {\n            // If no saved emotes, initialize with default emotes\n            this.ownedEmotes = new Set([Emote.Happy, Emote.Sad, Emote.Angry, Emote.Surprised]);\n        }\n    };\n    Player.prototype.setPosition = function (x, y) {\n        this.x = x;\n        this.y = y;\n    };\n    Player.prototype.setInAlternateDimension = function (value) {\n        this.isInAlternateDimension = value;\n        if (value) {\n            this.normalSize = this.size; // Store the current size\n            this.size = this.alternateDimensionSize; // Set to slightly larger size\n        }\n        else {\n            this.size = this.normalSize; // Restore the normal size\n        }\n    };\n    Player.prototype.adjustAlternateDimensionScore = function (amount) {\n        this.alternateDimensionScore += amount;\n        this.score += amount; // Add the amount to the regular score as well\n        this.setSize(this.getScore() + this.getGoldScore());\n        console.log(\"Alternate Dimension Score adjusted. New score: \".concat(this.alternateDimensionScore));\n        console.log(\"Regular Score adjusted. New score: \".concat(this.score));\n    };\n    Player.prototype.getAlternateDimensionScore = function () {\n        return this.alternateDimensionScore;\n    };\n    Player.prototype.isDead = function () {\n        return this.health <= 0;\n    };\n    Player.prototype.getMaxHealth = function () {\n        return this.maxHealth;\n    };\n    return Player;\n}());\nexports.Player = Player;\n\n\n//# sourceURL=webpack:///./src/player.ts?");

/***/ }),

/***/ "./src/shop.ts":
/*!*********************!*\
  !*** ./src/shop.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Shop = void 0;\nvar player_1 = __webpack_require__(/*! ./player */ \"./src/player.ts\");\nvar Shop = /** @class */ (function () {\n    function Shop(player, context, game) {\n        this.isOpen = false;\n        this.allEmotes = Object.values(player_1.Emote).filter(function (value) { return typeof value === 'number'; });\n        this.availableEmotes = [];\n        this.SHOP_SIZE = 8;\n        this.player = player;\n        this.context = context;\n        this.game = game;\n        this.initializeAvailableEmotes();\n    }\n    Shop.prototype.initializeAvailableEmotes = function () {\n        var ownedEmotes = new Set(this.player.getOwnedEmotes());\n        var unownedEmotes = this.allEmotes.filter(function (emote) { return !ownedEmotes.has(emote); });\n        this.availableEmotes = this.getRandomEmotes(unownedEmotes, this.SHOP_SIZE);\n    };\n    Shop.prototype.getRandomEmotes = function (emotes, count) {\n        var shuffled = __spreadArray([], emotes, true).sort(function () { return 0.5 - Math.random(); });\n        return shuffled.slice(0, count);\n    };\n    Shop.prototype.toggleShop = function () {\n        this.isOpen = !this.isOpen;\n        if (this.isOpen) {\n            this.updateAvailableEmotes();\n        }\n    };\n    Shop.prototype.updateAvailableEmotes = function () {\n        var _a;\n        var _this = this;\n        var ownedEmotes = new Set(this.player.getOwnedEmotes());\n        this.availableEmotes = this.availableEmotes.filter(function (emote) { return !ownedEmotes.has(emote); });\n        var unownedEmotes = this.allEmotes.filter(function (emote) { return !ownedEmotes.has(emote) && !_this.availableEmotes.includes(emote); });\n        var newEmotes = this.getRandomEmotes(unownedEmotes, this.SHOP_SIZE - this.availableEmotes.length);\n        (_a = this.availableEmotes).push.apply(_a, newEmotes);\n    };\n    Shop.prototype.isShopOpen = function () {\n        return this.isOpen;\n    };\n    Shop.prototype.render = function (canvasWidth, canvasHeight) {\n        var _this = this;\n        if (!this.isOpen)\n            return;\n        var shopWidth = 300;\n        var shopHeight = 400;\n        var x = (canvasWidth - shopWidth) / 2;\n        var y = (canvasHeight - shopHeight) / 2;\n        // Draw shop background\n        this.context.fillStyle = 'rgba(0, 0, 0, 0.8)';\n        this.context.fillRect(x, y, shopWidth, shopHeight);\n        // Draw shop title\n        this.context.fillStyle = 'white';\n        this.context.font = '24px Arial';\n        this.context.textAlign = 'center';\n        this.context.fillText('Emote Shop', x + shopWidth / 2, y + 30);\n        // Draw player's gold\n        this.context.fillStyle = 'gold';\n        this.context.font = '18px Arial';\n        this.context.fillText(\"Gold: \".concat(this.player.getGoldScore()), x + shopWidth / 2, y + 60);\n        // Draw emotes\n        var emoteSize = 40;\n        var columns = 4;\n        var padding = 10;\n        var startX = x + (shopWidth - (emoteSize + padding) * columns + padding) / 2;\n        var startY = y + 80;\n        this.availableEmotes.forEach(function (emote, index) {\n            var emoteX = startX + (index % columns) * (emoteSize + padding);\n            var emoteY = startY + Math.floor(index / columns) * (emoteSize + padding);\n            // Draw emote background\n            _this.context.fillStyle = 'rgba(255, 255, 255, 0.2)';\n            _this.context.fillRect(emoteX, emoteY, emoteSize, emoteSize);\n            // Draw emote\n            _this.context.font = \"\".concat(emoteSize * 0.7, \"px Arial\");\n            _this.context.fillStyle = 'white';\n            _this.context.fillText(_this.getEmoteText(emote), emoteX + emoteSize / 2, emoteY + emoteSize * 0.7);\n            // Draw price\n            _this.context.font = '12px Arial';\n            _this.context.fillStyle = 'gold';\n            _this.context.fillText('300', emoteX + emoteSize / 2, emoteY + emoteSize - 5);\n        });\n    };\n    Shop.prototype.handleClick = function (x, y, canvasWidth, canvasHeight) {\n        var _this = this;\n        if (!this.isOpen)\n            return;\n        var shopWidth = 300;\n        var shopHeight = 400;\n        var shopX = (canvasWidth - shopWidth) / 2;\n        var shopY = (canvasHeight - shopHeight) / 2;\n        var emoteSize = 40;\n        var columns = 4;\n        var padding = 10;\n        var startX = shopX + (shopWidth - (emoteSize + padding) * columns + padding) / 2;\n        var startY = shopY + 80;\n        this.availableEmotes.forEach(function (emote, index) {\n            var emoteX = startX + (index % columns) * (emoteSize + padding);\n            var emoteY = startY + Math.floor(index / columns) * (emoteSize + padding);\n            if (x >= emoteX && x < emoteX + emoteSize && y >= emoteY && y < emoteY + emoteSize) {\n                _this.buyEmote(emote);\n            }\n        });\n    };\n    Shop.prototype.buyEmote = function (emote) {\n        if (this.player.buyEmote(emote)) {\n            console.log(\"Bought emote: \".concat(player_1.Emote[emote]));\n            this.game.getSoundManager().playBuyEmoteSound();\n        }\n        else {\n            console.log(\"Not enough gold to buy emote: \".concat(player_1.Emote[emote]));\n        }\n    };\n    Shop.prototype.getEmoteText = function (emote) {\n        switch (emote) {\n            case player_1.Emote.Happy: return '';\n            case player_1.Emote.Sad: return '';\n            case player_1.Emote.Angry: return '';\n            case player_1.Emote.Surprised: return '';\n            case player_1.Emote.Love: return '';\n            case player_1.Emote.Cool: return '';\n            case player_1.Emote.Thinking: return '';\n            case player_1.Emote.Laughing: return '';\n            case player_1.Emote.Wink: return '';\n            case player_1.Emote.Confused: return '';\n            case player_1.Emote.Sleepy: return '';\n            case player_1.Emote.Excited: return '';\n            case player_1.Emote.Nervous: return '';\n            case player_1.Emote.Sick: return '';\n            case player_1.Emote.Rich: return '';\n            case player_1.Emote.Strong: return '';\n            case player_1.Emote.Scared: return '';\n            case player_1.Emote.Crazy: return '';\n            case player_1.Emote.Evil: return '';\n            case player_1.Emote.Dead: return '';\n            default: return '';\n        }\n    };\n    return Shop;\n}());\nexports.Shop = Shop;\n\n\n//# sourceURL=webpack:///./src/shop.ts?");

/***/ }),

/***/ "./src/soundManager.ts":
/*!*****************************!*\
  !*** ./src/soundManager.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SoundManager = void 0;\nvar SoundManager = /** @class */ (function () {\n    function SoundManager() {\n        this.angryBeeBuzzNode = null;\n        this.beeBuzzGainNode = null;\n        this.isMuted = false;\n        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        this.masterGainNode = this.audioContext.createGain();\n        this.masterGainNode.connect(this.audioContext.destination);\n        this.setVolume(0.5); // Set default volume to 50%\n    }\n    SoundManager.prototype.setMute = function (mute) {\n        this.isMuted = mute;\n        if (this.isMuted) {\n            this.masterGainNode.gain.setValueAtTime(0, this.audioContext.currentTime);\n        }\n        else {\n            this.masterGainNode.gain.setValueAtTime(this.getVolume(), this.audioContext.currentTime);\n        }\n        // Stop the bee sound if it's playing and we're muting\n        if (this.isMuted && this.angryBeeBuzzNode) {\n            this.stopAngryBeeSound();\n        }\n    };\n    SoundManager.prototype.setVolume = function (volume) {\n        if (volume < 0 || volume > 1) {\n            throw new Error('Volume must be between 0 and 1');\n        }\n        if (!this.isMuted) {\n            this.masterGainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);\n        }\n    };\n    SoundManager.prototype.getVolume = function () {\n        return this.masterGainNode.gain.value;\n    };\n    SoundManager.prototype.playCollectSound = function () {\n        this.playSound(440, 0.1, 'sine');\n    };\n    SoundManager.prototype.playHurtSound = function () {\n        this.playSound(100, 0.2, 'sawtooth');\n    };\n    SoundManager.prototype.playPortalSound = function () {\n        this.playSweep(300, 600, 0.3);\n    };\n    SoundManager.prototype.playBackgroundMusic = function () {\n        this.playAmbientSound();\n    };\n    SoundManager.prototype.playGoldDigSound = function () {\n        this.playSound(660, 0.1, 'sine'); // Higher pitch for gold\n    };\n    SoundManager.prototype.playBuyEmoteSound = function () {\n        this.playSweep(440, 880, 0.2); // Upward sweep for purchase\n    };\n    SoundManager.prototype.playAngryBeeSound = function () {\n        if (this.isMuted)\n            return; // Don't play if muted\n        console.log(\"Playing angry bee sound\");\n        if (this.angryBeeBuzzNode) {\n            this.stopAngryBeeSound();\n        }\n        this.startContinuousBuzz();\n    };\n    SoundManager.prototype.stopAngryBeeSound = function () {\n        if (this.angryBeeBuzzNode) {\n            this.angryBeeBuzzNode.stop();\n            this.angryBeeBuzzNode.disconnect();\n            this.angryBeeBuzzNode = null;\n        }\n        if (this.beeBuzzGainNode) {\n            this.beeBuzzGainNode.disconnect();\n            this.beeBuzzGainNode = null;\n        }\n    };\n    SoundManager.prototype.startContinuousBuzz = function () {\n        var fundamentalFreq = 100; // Base frequency at 100 Hz\n        var maxFreq = 150; // Maximum frequency for harmonics\n        var oscillator = this.audioContext.createOscillator();\n        var gainNode = this.audioContext.createGain();\n        oscillator.type = 'sawtooth'; // Use sawtooth for a richer harmonic content\n        oscillator.frequency.setValueAtTime(fundamentalFreq, this.audioContext.currentTime);\n        // Create a slight wobble effect for the fundamental frequency\n        this.addFrequencyModulation(oscillator, 8, 2);\n        // Add harmonics, but limit their frequency to maxFreq\n        this.addHarmonic(oscillator, 2, 0.5, maxFreq); // Second harmonic\n        this.addHarmonic(oscillator, 3, 0.3, maxFreq); // Third harmonic\n        this.addHarmonic(oscillator, 4, 0.2, maxFreq); // Fourth harmonic\n        oscillator.connect(gainNode);\n        gainNode.connect(this.masterGainNode);\n        // Increase the volume to match other sounds\n        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);\n        gainNode.gain.exponentialRampToValueAtTime(0.1, this.audioContext.currentTime + 0.1); // Increased from 0.02 to 0.1\n        oscillator.start();\n        this.angryBeeBuzzNode = oscillator;\n        this.beeBuzzGainNode = gainNode;\n        // Add amplitude modulation for a more natural buzz\n        this.addAmplitudeModulation(gainNode);\n    };\n    SoundManager.prototype.addFrequencyModulation = function (oscillator, modulationFreq, modulationAmount) {\n        var modulator = this.audioContext.createOscillator();\n        var modulationIndex = this.audioContext.createGain();\n        modulator.frequency.setValueAtTime(modulationFreq, this.audioContext.currentTime);\n        modulationIndex.gain.setValueAtTime(modulationAmount, this.audioContext.currentTime);\n        modulator.connect(modulationIndex);\n        modulationIndex.connect(oscillator.frequency);\n        modulator.start();\n    };\n    SoundManager.prototype.addHarmonic = function (fundamentalOscillator, harmonicNumber, gainValue, maxFreq) {\n        var harmonicOscillator = this.audioContext.createOscillator();\n        var harmonicGain = this.audioContext.createGain();\n        harmonicOscillator.type = 'sawtooth';\n        var harmonicFreq = Math.min(fundamentalOscillator.frequency.value * harmonicNumber, maxFreq);\n        harmonicOscillator.frequency.setValueAtTime(harmonicFreq, this.audioContext.currentTime);\n        harmonicGain.gain.setValueAtTime(gainValue, this.audioContext.currentTime);\n        harmonicOscillator.connect(harmonicGain);\n        harmonicGain.connect(this.masterGainNode);\n        harmonicOscillator.start();\n    };\n    SoundManager.prototype.addAmplitudeModulation = function (gainNode) {\n        var modulator = this.audioContext.createOscillator();\n        var modulatorGain = this.audioContext.createGain();\n        modulator.type = 'sine';\n        modulator.frequency.setValueAtTime(30, this.audioContext.currentTime);\n        modulatorGain.gain.setValueAtTime(0.3, this.audioContext.currentTime); // Increased from 0.1 to 0.3\n        modulator.connect(modulatorGain);\n        modulatorGain.connect(gainNode.gain);\n        modulator.start();\n    };\n    SoundManager.prototype.playSound = function (frequency, duration, type) {\n        if (this.isMuted)\n            return; // Don't play if muted\n        var oscillator = this.audioContext.createOscillator();\n        var gainNode = this.audioContext.createGain();\n        oscillator.type = type;\n        oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);\n        oscillator.connect(gainNode);\n        gainNode.connect(this.masterGainNode);\n        // Reduce the volume here\n        gainNode.gain.setValueAtTime(0.05, this.audioContext.currentTime); // Changed from 0.1 to 0.05\n        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);\n        oscillator.start();\n        oscillator.stop(this.audioContext.currentTime + duration);\n    };\n    SoundManager.prototype.playSweep = function (startFreq, endFreq, duration) {\n        if (this.isMuted)\n            return; // Don't play if muted\n        var oscillator = this.audioContext.createOscillator();\n        var gainNode = this.audioContext.createGain();\n        oscillator.type = 'sine';\n        oscillator.frequency.setValueAtTime(startFreq, this.audioContext.currentTime);\n        oscillator.frequency.exponentialRampToValueAtTime(endFreq, this.audioContext.currentTime + duration);\n        oscillator.connect(gainNode);\n        gainNode.connect(this.masterGainNode);\n        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);\n        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);\n        oscillator.start();\n        oscillator.stop(this.audioContext.currentTime + duration);\n    };\n    SoundManager.prototype.playAmbientSound = function () {\n        var _this = this;\n        if (this.isMuted)\n            return; // Don't play if muted\n        var oscillator = this.audioContext.createOscillator();\n        var gainNode = this.audioContext.createGain();\n        oscillator.type = 'sine';\n        oscillator.frequency.setValueAtTime(50, this.audioContext.currentTime);\n        oscillator.connect(gainNode);\n        gainNode.connect(this.masterGainNode);\n        // Reduce the volume of the ambient sound\n        gainNode.gain.setValueAtTime(0.01, this.audioContext.currentTime); // Changed from 0.02 to 0.01\n        oscillator.start();\n        // Modulate the frequency slightly for an ambient effect\n        setInterval(function () {\n            var newFreq = 45 + Math.random() * 10;\n            oscillator.frequency.exponentialRampToValueAtTime(newFreq, _this.audioContext.currentTime + 2);\n        }, 2000);\n    };\n    SoundManager.prototype.playBuzzSound = function (baseFreq, maxFreq, duration) {\n        if (this.isMuted)\n            return; // Don't play if muted\n        var oscillator1 = this.audioContext.createOscillator();\n        var oscillator2 = this.audioContext.createOscillator();\n        var gainNode = this.audioContext.createGain();\n        oscillator1.type = 'sawtooth';\n        oscillator2.type = 'triangle';\n        // Create a buzzing effect by rapidly alternating between two frequencies\n        var lfoFreq = 30; // Frequency of oscillation between base and max frequency\n        var now = this.audioContext.currentTime;\n        oscillator1.frequency.setValueAtTime(baseFreq, now);\n        oscillator2.frequency.setValueAtTime(baseFreq * 1.01, now); // Slightly detuned for richer sound\n        oscillator1.frequency.setValueCurveAtTime(new Float32Array([baseFreq, maxFreq, baseFreq]), now, duration);\n        oscillator2.frequency.setValueCurveAtTime(new Float32Array([baseFreq * 1.01, maxFreq * 1.01, baseFreq * 1.01]), now, duration);\n        oscillator1.connect(gainNode);\n        oscillator2.connect(gainNode);\n        gainNode.connect(this.masterGainNode);\n        gainNode.gain.setValueAtTime(0.1, now);\n        gainNode.gain.linearRampToValueAtTime(0.3, now + duration * 0.1);\n        gainNode.gain.linearRampToValueAtTime(0.1, now + duration);\n        oscillator1.start(now);\n        oscillator2.start(now);\n        oscillator1.stop(now + duration);\n        oscillator2.stop(now + duration);\n    };\n    return SoundManager;\n}());\nexports.SoundManager = SoundManager;\n\n\n//# sourceURL=webpack:///./src/soundManager.ts?");

/***/ }),

/***/ "./src/terrain.ts":
/*!************************!*\
  !*** ./src/terrain.ts ***!
  \************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Terrain = void 0;\nvar Terrain = /** @class */ (function () {\n    function Terrain(width, height) {\n        this.dugColor = '#3D2817'; // Dark brown color for dug areas\n        this.width = width;\n        this.height = height;\n        this.blocks = this.createBlocks();\n        this.portalLocation = { x: Math.floor(width / 20), y: Math.floor(height / 20) };\n        this.createPortal();\n    }\n    Terrain.prototype.createBlocks = function () {\n        var blocks = [];\n        for (var i = 0; i < this.width; i += 10) {\n            var row = [];\n            for (var j = 0; j < this.height; j += 10) {\n                row.push({ type: 'dirt', present: true });\n            }\n            blocks.push(row);\n        }\n        // Generate clusters of ore types\n        this.generateClusters(blocks, 'diamond', 0.0001, 3, 7);\n        this.generateClusters(blocks, 'uranium', 0.00005, 2, 5);\n        this.generateClusters(blocks, 'lava', 0.0002, 3, 6);\n        this.generateClusters(blocks, 'quartz', 0.0001, 3, 7);\n        this.generateClusters(blocks, 'bedrock', 0.00005, 2, 5);\n        this.generateClusters(blocks, 'gold_ore', 0.00015, 3, 6); // Add gold ore generation\n        this.generateGeodes(blocks, 0.000005, 5, 8);\n        return blocks;\n    };\n    Terrain.prototype.generateClusters = function (blocks, type, chance, minSize, maxSize) {\n        for (var i = 0; i < blocks.length; i++) {\n            for (var j = 0; j < blocks[i].length; j++) {\n                if (Math.random() < chance) {\n                    var clusterSize = this.getRandomClusterSize(minSize, maxSize);\n                    this.createCluster(blocks, i, j, type, clusterSize);\n                }\n            }\n        }\n    };\n    Terrain.prototype.createCluster = function (blocks, x, y, type, size) {\n        for (var dx = -size; dx <= size; dx++) {\n            for (var dy = -size; dy <= size; dy++) {\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                if (distance <= size) {\n                    var i = x + dx;\n                    var j = y + dy;\n                    if (i >= 0 && i < blocks.length && j >= 0 && j < blocks[i].length) {\n                        // Use noise to determine if this block should be part of the cluster\n                        if (this.noise(i, j, size) > 0.5) {\n                            if (type === 'bedrock') {\n                                blocks[i][j] = { type: type, present: true, durability: 50 }; // Increased durability for bedrock\n                            }\n                            else {\n                                blocks[i][j] = { type: type, present: true };\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    Terrain.prototype.generateGeodes = function (blocks, chance, minSize, maxSize) {\n        for (var i = 0; i < blocks.length; i++) {\n            for (var j = 0; j < blocks[i].length; j++) {\n                if (Math.random() < chance) {\n                    var geodeSize = this.getRandomClusterSize(minSize, maxSize);\n                    this.createGeode(blocks, i, j, geodeSize);\n                }\n            }\n        }\n    };\n    Terrain.prototype.createGeode = function (blocks, x, y, size) {\n        for (var dx = -size; dx <= size; dx++) {\n            for (var dy = -size; dy <= size; dy++) {\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                if (distance <= size) {\n                    var i = x + dx;\n                    var j = y + dy;\n                    if (i >= 0 && i < blocks.length && j >= 0 && j < blocks[i].length) {\n                        if (this.noise(i, j, size) > 0.5) {\n                            if (distance <= size / 2) {\n                                // Diamond core\n                                blocks[i][j] = { type: 'diamond', present: true };\n                            }\n                            else {\n                                // Bedrock shell with higher durability\n                                blocks[i][j] = { type: 'bedrock', present: true, durability: 100 };\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    Terrain.prototype.noise = function (x, y, size) {\n        // Simple noise function, you can replace this with a more sophisticated one if needed\n        var value = Math.sin(x * 0.1) + Math.sin(y * 0.1) + Math.sin((x + y) * 0.1);\n        return (Math.sin(value * size) + 1) / 2; // Normalize to 0-1 range\n    };\n    Terrain.prototype.getRandomClusterSize = function (min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    };\n    Terrain.prototype.generateTerrain = function (context, startX, startY, endX, endY) {\n        // Ensure we're not trying to access blocks outside the terrain\n        startX = Math.max(0, startX);\n        startY = Math.max(0, startY);\n        endX = Math.min(this.width / 10, endX);\n        endY = Math.min(this.height / 10, endY);\n        for (var x = startX; x < endX; x++) {\n            for (var y = startY; y < endY; y++) {\n                if (!this.blocks[x]) {\n                    this.blocks[x] = [];\n                }\n                if (!this.blocks[x][y]) {\n                    this.blocks[x][y] = this.generateBlock(x, y);\n                }\n                var block = this.blocks[x][y];\n                if (block) {\n                    context.fillStyle = block.present ? this.getBlockColor(block.type) : this.dugColor;\n                    context.fillRect(x * 10, y * 10, 10, 10);\n                }\n            }\n        }\n    };\n    Terrain.prototype.removeBlock = function (x, y) {\n        var blockX = Math.floor(x / 10);\n        var blockY = Math.floor(y / 10);\n        if (this.blocks[blockX] && this.blocks[blockX][blockY] && this.blocks[blockX][blockY].present) {\n            var block = this.blocks[blockX][blockY];\n            if (block.type === 'portal') {\n                return null; // Portal blocks cannot be removed\n            }\n            if (block.type === 'bedrock') {\n                if (block.durability && block.durability > 1) {\n                    this.blocks[blockX][blockY] = __assign(__assign({}, block), { durability: block.durability - 1 });\n                    return null; // Return null to indicate the block wasn't fully removed\n                }\n            }\n            this.blocks[blockX][blockY] = __assign(__assign({}, block), { present: false });\n            return block;\n        }\n        return null;\n    };\n    Terrain.prototype.generateBlock = function (x, y) {\n        // You can implement more complex logic here if needed\n        return { type: 'dirt', present: true };\n    };\n    Terrain.prototype.getBlockColor = function (type) {\n        switch (type) {\n            case 'dirt':\n                return '#8B4513'; // Saddle Brown\n            case 'diamond':\n                return '#00FFFF'; // Cyan\n            case 'uranium':\n                return '#32CD32'; // Lime Green\n            case 'lava':\n                return '#FF4500'; // Orange Red\n            case 'quartz':\n                return '#F0F8FF'; // Alice Blue\n            case 'bedrock':\n                return '#4A4A4A'; // Dark gray for bedrock\n            case 'gold_ore':\n                return '#FFD700'; // Gold color\n            case 'portal':\n                return '#8A2BE2'; // BlueViolet color for the portal\n            default:\n                return '#A9A9A9'; // Dark Gray\n        }\n    };\n    Terrain.prototype.getBlock = function (x, y) {\n        var blockX = Math.floor(x / 10);\n        var blockY = Math.floor(y / 10);\n        if (this.blocks[blockX] && this.blocks[blockX][blockY]) {\n            return this.blocks[blockX][blockY];\n        }\n        return null;\n    };\n    Terrain.prototype.getPortalLocation = function () {\n        return { x: this.portalLocation.x * 10, y: this.portalLocation.y * 10 };\n    };\n    Terrain.prototype.getWidth = function () {\n        return this.width;\n    };\n    Terrain.prototype.getHeight = function () {\n        return this.height;\n    };\n    Terrain.prototype.createPortal = function () {\n        var portalSize = 5;\n        for (var i = -portalSize; i <= portalSize; i++) {\n            for (var j = -portalSize; j <= portalSize; j++) {\n                if (i * i + j * j <= portalSize * portalSize) {\n                    var x = this.portalLocation.x + i;\n                    var y = this.portalLocation.y + j;\n                    if (x >= 0 && x < this.width / 10 && y >= 0 && y < this.height / 10) {\n                        this.blocks[x][y] = { type: 'portal', present: true };\n                    }\n                }\n            }\n        }\n    };\n    return Terrain;\n}());\nexports.Terrain = Terrain;\n\n\n//# sourceURL=webpack:///./src/terrain.ts?");

/***/ }),

/***/ "./src/titleScreen.ts":
/*!****************************!*\
  !*** ./src/titleScreen.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TitleScreen = void 0;\nvar player_1 = __webpack_require__(/*! ./player */ \"./src/player.ts\");\nvar enemy_1 = __webpack_require__(/*! ./enemy */ \"./src/enemy.ts\");\nvar terrain_1 = __webpack_require__(/*! ./terrain */ \"./src/terrain.ts\");\nvar TitleScreen = /** @class */ (function () {\n    function TitleScreen(canvas, context, onStart, volumeSlider, muteButton) {\n        this.canvas = canvas;\n        this.context = context;\n        this.onStart = onStart;\n        this.volumeSlider = volumeSlider;\n        this.muteButton = muteButton;\n    }\n    TitleScreen.prototype.show = function () {\n        this.draw();\n        this.setupEventListeners();\n        this.volumeSlider.style.display = 'none';\n        this.muteButton.style.display = 'none';\n    };\n    TitleScreen.prototype.draw = function () {\n        var tempTerrain = new terrain_1.Terrain(this.canvas.width, this.canvas.height);\n        // Background\n        this.context.fillStyle = 'black';\n        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        // Draw some terrain\n        tempTerrain.generateTerrain(this.context, 0, 0, this.canvas.width / 10, this.canvas.height / 10);\n        // Create and draw a player\n        var player = new player_1.Player(this.canvas.width / 2, this.canvas.height / 2, 100, 10, this.context, tempTerrain, null);\n        player.setSize(40);\n        player.draw(this.canvas.width, this.canvas.height);\n        // Create and draw some enemies\n        for (var i = 0; i < 5; i++) {\n            var enemy = new enemy_1.Enemy(Math.random() * this.canvas.width, Math.random() * this.canvas.height, this.canvas.width, this.canvas.height, this.context, player, tempTerrain, null // Pass null as Game instance for the title screen\n            );\n            enemy.setSize(30);\n            enemy.draw(this.canvas.width, this.canvas.height); // Pass canvas width and height\n        }\n        // Title\n        this.context.fillStyle = 'white';\n        this.context.font = '48px Arial';\n        this.context.textAlign = 'center';\n        this.context.fillText('DigDig', this.canvas.width / 2, this.canvas.height / 2 - 50);\n        // Start button\n        this.drawStartButton();\n    };\n    TitleScreen.prototype.drawStartButton = function () {\n        var buttonWidth = 200;\n        var buttonHeight = 50;\n        var buttonX = this.canvas.width / 2 - buttonWidth / 2;\n        var buttonY = this.canvas.height / 2 + 50;\n        this.context.fillStyle = 'green';\n        this.context.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);\n        this.context.fillStyle = 'white';\n        this.context.font = '24px Arial';\n        this.context.fillText('Start Game', this.canvas.width / 2, buttonY + buttonHeight / 2 + 8);\n    };\n    TitleScreen.prototype.setupEventListeners = function () {\n        var _this = this;\n        this.canvas.onclick = function (event) { return _this.handleClick(event); };\n    };\n    TitleScreen.prototype.handleClick = function (event) {\n        var rect = this.canvas.getBoundingClientRect();\n        var x = event.clientX - rect.left;\n        var y = event.clientY - rect.top;\n        var buttonWidth = 200;\n        var buttonHeight = 50;\n        var buttonX = this.canvas.width / 2 - buttonWidth / 2;\n        var buttonY = this.canvas.height / 2 + 50;\n        if (x >= buttonX && x <= buttonX + buttonWidth &&\n            y >= buttonY && y <= buttonY + buttonHeight) {\n            this.canvas.onclick = null;\n            this.volumeSlider.style.display = 'block';\n            this.muteButton.style.display = 'block';\n            this.onStart();\n        }\n    };\n    return TitleScreen;\n}());\nexports.TitleScreen = TitleScreen;\n\n\n//# sourceURL=webpack:///./src/titleScreen.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;